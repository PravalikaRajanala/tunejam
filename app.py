import os
import json
import eventlet
eventlet.monkey_patch() # Patch standard library for async operations (e.g., requests)

from flask import Flask, request, Response, abort, render_template, jsonify
from flask_cors import CORS
from flask_socketio import SocketIO, emit, join_room, leave_room
import yt_dlp # For fetching YouTube metadata
import logging
import uuid
import re # For regex parsing URLs
import random
import firebase_admin
from firebase_admin import credentials, firestore, auth

# Initialize Flask app, telling it to look for templates in the current directory (root)
app = Flask(__name__, template_folder='.')
CORS(app) # Enable CORS for frontend requests
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

socketio = SocketIO(app, cors_allowed_origins="*")

# --- CONFIGURATION ---
# Removed Google Drive specific config and temporary download directory as they are no longer needed.

# --- Firebase Admin SDK Initialization (for Firestore) ---
db = None # Initialize db as None
try:
    firebase_credentials_json = os.environ.get('FIREBASE_ADMIN_CREDENTIALS_JSON')

    if firebase_credentials_json:
        cred_dict = json.loads(firebase_credentials_json)
        cred = credentials.Certificate(cred_dict)
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
        db = firestore.client()
        logging.info("Firebase Admin SDK initialized successfully from environment variable.")
    else:
        FIREBASE_ADMIN_KEY_FILE_LOCAL = 'firebase_admin_key.json'
        if os.path.exists(FIREBASE_ADMIN_KEY_FILE_LOCAL):
            if not firebase_admin._apps:
                cred = credentials.Certificate(FIREBASE_ADMIN_KEY_FILE_LOCAL)
                firebase_admin.initialize_app(cred)
            db = firestore.client()
            logging.info("Firebase Admin SDK initialized successfully from local file (for development).")
        else:
            logging.error("Firebase Admin SDK credentials not found. Set 'FIREBASE_ADMIN_CREDENTIALS_JSON' "
                          "environment variable on Vercel or provide 'firebase_admin_key.json' for local development.")
            db = None
except Exception as e:
    logging.error(f"Error initializing Firebase Admin SDK: {e}")
    db = None

# --- Hosted MP3 Songs Manifest ---
# This manifest needs to be generated by your MP3 organization script
# and deployed alongside this app.py.
HOSTED_SONGS_MANIFEST_FILE = 'hosted_songs_manifest.json'
HOSTED_SONGS_DATA = []

def load_hosted_songs_manifest():
    """Loads the hosted songs manifest from a JSON file."""
    global HOSTED_SONGS_DATA
    try:
        with open(HOSTED_SONGS_MANIFEST_FILE, 'r', encoding='utf-8') as f:
            HOSTED_SONGS_DATA = json.load(f)
        logging.info(f"Loaded {len(HOSTED_SONGS_DATA)} songs from {HOSTED_SONGS_MANIFEST_FILE}")
    except FileNotFoundError:
        logging.warning(f"Hosted songs manifest file '{HOSTED_SONGS_MANIFEST_FILE}' not found. Hosted MP3 search will not work.")
        HOSTED_SONGS_DATA = []
    except json.JSONDecodeError as e:
        logging.error(f"Error decoding JSON from {HOSTED_SONGS_MANIFEST_FILE}: {e}")
        HOSTED_SONGS_DATA = []
    except Exception as e:
        logging.error(f"Unexpected error loading {HOSTED_SONGS_MANIFEST_FILE}: {e}")
        HOSTED_SONGS_DATA = []

# Load the manifest when the app starts (e.g., during cold start on Vercel)
load_hosted_songs_manifest()


# This dictionary will store active jam sessions primarily for SocketIO tracking.
jam_sessions = {}
sids_in_jams = {} # { socket_id: { 'jam_id': '...', 'nickname': '...' } }

# --- Helper for getting base URL for shareable links ---
def get_base_url():
    return request.host_url

# --- Flask Routes ---
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/join/<jam_id>')
def join_by_link(jam_id):
    logging.info(f"Received request to join jam via link: {jam_id}")
    return render_template('index.html', initial_jam_id=jam_id)

@app.route('/youtube_info')
def youtube_info():
    url = request.args.get('url')
    if not url:
        return jsonify({"error": "URL parameter is missing."}), 400

    ydl_opts = {
        'format': 'bestaudio/best',
        'noplaylist': True,
        'quiet': True,
        'no_warnings': True,
        'force_ipv4': True,
        'geo_bypass': True,
        'age_limit': 99,
        'logger': logging.getLogger(),
        'simulate': True,
        'extract_flat': 'in_playlist'
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            
            if 'entries' in info and info['entries']:
                info = info['entries'][0]
            elif 'entries' in info and not info['entries']:
                return jsonify({"error": "No entries found for the provided YouTube URL/playlist."}), 404

            video_id = info.get('id')
            title = info.get('title')
            uploader = info.get('uploader')
            thumbnail = info.get('thumbnail')
            duration = info.get('duration')

            if not video_id:
                logging.error(f"Could not extract video ID for URL: {url}")
                return jsonify({"error": "Could not extract video ID from the provided URL. Is it a valid YouTube video?"}), 400

            high_res_thumbnail = thumbnail
            if 'thumbnails' in info:
                sorted_thumbnails = sorted(info['thumbnails'], key=lambda x: x.get('width', 0) * x.get('height', 0), reverse=True)
                for thumb in sorted_thumbnails:
                    if thumb.get('url'):
                        high_res_thumbnail = thumb['url']
                        break

            return jsonify({
                "video_id": video_id,
                "title": title,
                "artist": uploader,
                "thumbnail": high_res_thumbnail,
                "duration": duration,
                "type": "youtube"
            })

    except yt_dlp.utils.DownloadError as e:
        logging.error(f"yt-dlp info extraction error for URL {url}: {e}")
        error_message = str(e).lower()
        if "unavailable" in error_message or "private" in error_message or "embedding is disabled" in error_message:
            return jsonify({"error": "YouTube video is restricted or unavailable."}), 403
        elif "age-restricted" in error_message:
            return jsonify({"error": "YouTube video is age-restricted."}), 403
        elif "read timeout" in error_message or "connection timed out" in error_message:
            return jsonify({"error": "YouTube info extraction timed out. Check URL or network."}), 504
        return jsonify({"error": f"Could not get YouTube video information: {e}"}), 500
    except Exception as e:
        logging.error(f"Unexpected error during YouTube info extraction for URL {url}: {e}")
        return jsonify({"error": f"Internal server error: {e}"}), 500


@app.route('/youtube_search')
def youtube_search_route():
    query = request.args.get('query')
    if not query:
        return jsonify({"error": "Query parameter is missing."}), 400

    ydl_opts = {
        'default_search': 'ytsearch10',
        'quiet': True,
        'no_warnings': True,
        'extract_flat': True,
        'force_ipv4': True,
        'geo_bypass': True,
        'logger': logging.getLogger(),
        'external_downloader_args': ['--socket-timeout', '15']
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(query, download=False)
            videos = []
            if 'entries' in info:
                for entry in info['entries']:
                    if entry and entry.get('id') and entry.get('title'):
                        high_res_thumbnail = entry.get('thumbnail', '')
                        if 'thumbnails' in entry:
                            sorted_thumbnails = sorted(entry['thumbnails'], key=lambda x: x.get('width', 0) * x.get('height', 0), reverse=True)
                            for thumb in sorted_thumbnails:
                                if thumb.get('url'):
                                    high_res_thumbnail = thumb['url']
                                    break

                        videos.append({
                            'id': entry['id'],
                            'title': entry['title'],
                            'artist': entry.get('uploader', 'Unknown'),
                            'thumbnail': high_res_thumbnail,
                            'duration': entry.get('duration'),
                            'type': 'youtube'
                        })
            return jsonify(videos)

    except yt_dlp.utils.DownloadError as e:
        logging.error(f"yt-dlp search error for query '{query}': {e}")
        error_message = str(e).lower()
        if "read timeout" in error_message or "connection timed out" in error_message:
            return jsonify({"error": "Search timed out. Try a more specific query."}), 504
        return jsonify({"error": f"YouTube search failed: {e}"}), 500
    except Exception as e:
        logging.error(f"Unexpected error during YouTube search for query '{query}': {e}")
        return jsonify({"error": f"Internal server error: {e}"}), 500


@app.route('/search_hosted_mp3s')
def search_hosted_mp3s():
    """
    Searches the loaded HOSTED_SONGS_DATA manifest for MP3s matching a query.
    """
    query = request.args.get('query', '').lower()
    
    if not HOSTED_SONGS_DATA:
        return jsonify({"error": "Hosted MP3 songs manifest not loaded or is empty on the server."}), 500

    filtered_songs = []
    for song in HOSTED_SONGS_DATA:
        if query in song.get('title', '').lower() or query in song.get('artist', '').lower():
            filtered_songs.append(song)
    
    logging.info(f"Found {len(filtered_songs)} hosted MP3s for query '{query}'")
    return jsonify(filtered_songs)

# --- SocketIO Event Handlers ---
@socketio.on('connect')
def handle_connect():
    logging.info(f"Client connected: {request.sid}")

@socketio.on('disconnect')
def handle_disconnect():
    logging.info(f"Client disconnected: {request.sid}")
    if request.sid in sids_in_jams:
        jam_id = sids_in_jams[request.sid]['jam_id']
        nickname = sids_in_jams[request.sid]['nickname']

        if db:
            jam_ref = db.collection('jam_sessions').document(jam_id)
            try:
                jam_doc = jam_ref.get()
                if jam_doc.exists:
                    jam_data = jam_doc.to_dict()
                    if jam_data['host_sid'] == request.sid:
                        logging.info(f"Host {nickname} ({request.sid}) for jam {jam_id} disconnected. Marking session as ended.")
                        jam_ref.update({'is_active': False, 'ended_at': firestore.SERVER_TIMESTAMP})
                        socketio.emit('session_ended', {'jam_id': jam_id, 'message': 'Host disconnected. Session ended.'}, room=jam_id)
                    else:
                        if request.sid in jam_data['participants']:
                            updated_participants = {sid: name for sid, name in jam_data['participants'].items() if sid != request.sid}
                            jam_ref.update({'participants': updated_participants})
                            logging.info(f"Participant {nickname} ({request.sid}) left jam {jam_id}.")
                            socketio.emit('update_participants', {
                                'jam_id': jam_id,
                                'participants': list(updated_participants.values())
                            }, room=jam_id)
                else:
                    logging.warning(f"Disconnected client {request.sid} was in jam {jam_id}, but jam not found in Firestore.")
            except Exception as e:
                logging.error(f"Error handling disconnect for jam {jam_id} in Firestore: {e}")
        
        if request.sid in sids_in_jams:
            del sids_in_jams[request.sid]
        
        leave_room(jam_id)

@socketio.on('create_session')
def create_session(data):
    if db is None:
        emit('join_failed', {'message': 'Server database not initialized. Cannot create session.'})
        return

    jam_name = data.get('jam_name', 'Unnamed Jam Session')
    nickname = data.get('nickname', 'Host')
    
    try:
        new_jam_doc_ref = db.collection('jam_sessions').document()
        jam_id = new_jam_doc_ref.id

        initial_jam_data = {
            'name': jam_name,
            'host_sid': request.sid,
            'participants': {request.sid: nickname},
            'playlist': [],
            'playback_state': {
                'current_track_index': 0,
                'current_playback_time': 0,
                'is_playing': False,
                'timestamp': firestore.SERVER_TIMESTAMP
            },
            'created_at': firestore.SERVER_TIMESTAMP,
            'is_active': True
        }
        new_jam_doc_ref.set(initial_jam_data)

        jam_sessions[jam_id] = {
            'name': jam_name,
            'host_sid': request.sid,
            'participants': {request.sid: nickname},
            'playlist': [],
            'playback_state': {
                'current_track_index': 0,
                'current_playback_time': 0,
                'is_playing': False,
                'timestamp': 0
            }
        }
        sids_in_jams[request.sid] = {'jam_id': jam_id, 'nickname': nickname}

        join_room(jam_id)
        logging.info(f"Jam session '{jam_name}' created with ID: {jam_id} by host {nickname} ({request.sid})")

        shareable_link = f"{get_base_url()}join/{jam_id}"

        emit('session_created', {
            'jam_id': jam_id,
            'jam_name': jam_name,
            'is_host': True,
            'initial_state': initial_jam_data['playback_state'],
            'participants': list(initial_jam_data['participants'].values()),
            'shareable_link': shareable_link
        })

    except Exception as e:
        logging.error(f"Error creating jam session in Firestore: {e}")
        emit('join_failed', {'message': f'Error creating session: {e}'})

@socketio.on('join_session')
def join_session_handler(data):
    if db is None:
        emit('join_failed', {'message': 'Server database not initialized. Cannot join session.'})
        return

    jam_id = data.get('jam_id')
    nickname = data.get('nickname', 'Guest')
    
    if not jam_id:
        logging.warning(f"Client {request.sid} attempted to join without jam_id.")
        emit('join_failed', {'message': 'Jam ID is missing.'})
        return

    try:
        jam_doc = db.collection('jam_sessions').document(jam_id).get()
        if not jam_doc.exists or not jam_doc.to_dict().get('is_active', False):
            logging.warning(f"Client {request.sid} attempted to join non-existent or inactive jam {jam_id}")
            emit('join_failed', {'message': 'Jam session not found or has ended.'})
            return

        jam_data = jam_doc.to_dict()
        
        updated_participants = jam_data.get('participants', {})
        updated_participants[request.sid] = nickname
        db.collection('jam_sessions').document(jam_id).update({'participants': updated_participants})

        if jam_id not in jam_sessions:
            jam_sessions[jam_id] = {
                'name': jam_data.get('name', 'Unnamed Jam'),
                'host_sid': jam_data.get('host_sid'),
                'playlist': jam_data.get('playlist', []),
                'playback_state': jam_data.get('playback_state', {})
            }
        jam_sessions[jam_id]['participants'] = updated_participants
        sids_in_jams[request.sid] = {'jam_id': jam_id, 'nickname': nickname}

        join_room(jam_id)
        logging.info(f"Client {nickname} ({request.sid}) joined jam {jam_id}")

        playback_state = jam_data.get('playback_state', {})
        emit('session_join_success', {
            'jam_id': jam_id,
            'current_track_index': playback_state.get('current_track_index', 0),
            'current_playback_time': playback_state.get('current_playback_time', 0),
            'is_playing': playback_state.get('is_playing', False),
            'playlist': jam_data.get('playlist', []),
            'jam_name': jam_data.get('name', 'Unnamed Jam'),
            'last_synced_at': playback_state.get('timestamp', firestore.SERVER_TIMESTAMP),
            'participants': updated_participants,
            'nickname_used': nickname
        })

        emit('update_participants', {
            'jam_id': jam_id,
            'participants': updated_participants
        }, room=jam_id, include_self=False)

    except Exception as e:
        logging.error(f"Error joining jam session {jam_id} in Firestore: {e}")
        emit('join_failed', {'message': f'Error joining session: {e}'})

@socketio.on('sync_playback_state')
def sync_playback_state(data):
    if db is None:
        return

    jam_id = data.get('jam_id')
    if not jam_id:
        return

    try:
        jam_doc = db.collection('jam_sessions').document(jam_id).get()
        if not jam_doc.exists:
            logging.warning(f"Sync request for non-existent jam {jam_id}")
            return
        
        jam_data = jam_doc.to_dict()
        if jam_data.get('host_sid') != request.sid:
            logging.warning(f"Non-host {request.sid} attempted to sync state for jam {jam_id}")
            return

        new_playback_state = {
            'current_track_index': data.get('current_track_index'),
            'current_playback_time': data.get('current_playback_time'),
            'is_playing': data.get('is_playing'),
            'timestamp': firestore.SERVER_TIMESTAMP
        }
        
        db.collection('jam_sessions').document(jam_id).update({
            'playback_state': new_playback_state,
            'playlist': data.get('playlist', [])
        })

    except Exception as e:
        logging.error(f"Error syncing playback state for jam {jam_id} to Firestore: {e}")

@socketio.on('add_song_to_jam')
def add_song_to_jam(data):
    if db is None:
        return

    jam_id = data.get('jam_id')
    song = data.get('song')

    if not jam_id or not song or not song.get('type') or not (song.get('url') or song.get('videoId')):
        logging.warning(f"Invalid add_song_to_jam request from {request.sid} for jam {jam_id}: {song}")
        return

    try:
        jam_ref = db.collection('jam_sessions').document(jam_id)
        jam_doc = jam_ref.get()
        if not jam_doc.exists:
            logging.warning(f"Add song request for non-existent jam {jam_id}")
            return

        jam_data = jam_doc.to_dict()
        if jam_data.get('host_sid') != request.sid:
            logging.warning(f"Non-host {request.sid} attempted to add song to jam {jam_id}")
            return

        updated_playlist = jam_data.get('playlist', [])
        song['id'] = str(uuid.uuid4())
        updated_playlist.append(song)
        
        jam_ref.update({'playlist': updated_playlist})
        logging.info(f"Song '{song.get('title', 'Unknown')}' (Type: {song.get('type')}) added to jam {jam_id} by host {request.sid} via Firestore.")

    except Exception as e:
        logging.error(f"Error adding song to jam {jam_id} in Firestore: {e}")

@socketio.on('remove_song_from_jam')
def remove_song_from_jam(data):
    if db is None:
        return

    jam_id = data.get('jam_id')
    song_id_to_remove = data.get('song_id')

    if not jam_id or not song_id_to_remove:
        logging.warning(f"Invalid remove_song_from_jam request from {request.sid} for jam {jam_id}")
        return

    try:
        jam_ref = db.collection('jam_sessions').document(jam_id)
        jam_doc = jam_ref.get()
        if not jam_doc.exists:
            logging.warning(f"Remove song request for non-existent jam {jam_id}")
            return

        jam_data = jam_doc.to_dict()
        if jam_data.get('host_sid') != request.sid:
            logging.warning(f"Non-host {request.sid} attempted to remove song from jam {jam_id}")
            return

        current_playlist = jam_data.get('playlist', [])
        
        index_to_remove = -1
        for i, song in enumerate(current_playlist):
            if song.get('id') == song_id_to_remove:
                index_to_remove = i
                break

        if index_to_remove != -1:
            removed_song = current_playlist.pop(index_to_remove)
            logging.info(f"Song '{removed_song.get('title', 'Unknown')}' removed from jam {jam_id} by host {request.sid} via Firestore.")

            current_track_index = jam_data['playback_state'].get('current_track_index', 0)
            if current_track_index == index_to_remove:
                if not current_playlist:
                    current_track_index = 0
                elif index_to_remove >= len(current_playlist):
                    current_track_index = 0
            elif current_track_index > index_to_remove:
                current_track_index -= 1
            
            jam_ref.update({
                'playlist': current_playlist,
                'playback_state.current_track_index': current_track_index,
                'playback_state.current_playback_time': 0,
                'playback_state.is_playing': jam_data['playback_state'].get('is_playing', False) and len(current_playlist) > 0
            })

    except Exception as e:
        logging.error(f"Error removing song from jam {jam_id} in Firestore: {e}")


if __name__ == '__main__':
    if db is None:
        logging.critical("Firestore not initialized. Exiting.")
        exit(1)
    socketio.run(app, debug=True, port=5000)

