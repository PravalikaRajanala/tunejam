<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TuneJam - Collaborative Audio Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <!-- Firebase SDK (New) -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, arrayUnion, arrayRemove, deleteDoc, collection, query, where, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your Firebase project configuration (REPLACE WITH YOUR ACTUAL CONFIG)
        const firebaseConfig = {
            apiKey: "AIzaSyAcVqgLOMO-5C8-lZbsjTQB1K7KRKf3Veg",
            authDomain: "audio-player-b4f54.firebaseapp.com",
            projectId: "audio-player-b4f54",
            storageBucket: "audio-player-b4f54.firebasestorage.app",
            messagingSenderId: "255619096574",
            appId: "1:255619096574:web:b8a7387e7761811858aaaf",
            measurementId: "G-42QFEP0HRT"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Make Firebase instances globally accessible for the script section
        window.firebaseApp = app;
        window.firebaseDb = db;
        window.firebaseAuth = auth;
        window.firebaseDoc = doc; // Expose doc for easier use
        window.firebaseOnSnapshot = onSnapshot; // Expose onSnapshot
        window.firebaseGetDoc = getDoc; // Expose getDoc
        window.firebaseSetDoc = setDoc; // Expose setDoc
        window.firebaseUpdateDoc = updateDoc; // Expose updateDoc
        window.firebaseDeleteDoc = deleteDoc; // Expose deleteDoc
        window.firebaseCollection = collection; // Expose collection
        window.firebaseSignInAnonymously = signInAnonymously; // Expose signInAnonymously
        window.firebaseOnAuthStateChanged = onAuthStateChanged; // Expose onAuthStateChanged
        window.firebaseSignInWithCustomToken = signInWithCustomToken; // Expose signInWithCustomToken
    </script>
    
    <style>
        /* Custom styles to enhance Tailwind's default behavior and provide specific overrides */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between player and playlist */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        @media (max-width: 768px) {
            body {
                flex-direction: column;
                padding: 10px;
            }
            .player-section, .playlist-section {
                width: 100%;
                max-width: none;
            }
        }
        .player-section, .playlist-section {
            background-color: #ffffff; /* White background for sections */
            border-radius: 1rem; /* Rounded corners */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1); /* Soft shadow */
            padding: 1.5rem;
            max-width: 450px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .player-section {
            align-items: center;
            text-align: center;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background-color: #4f46e5; /* Blue */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3); /* Focus ring effect */
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background-color: #4f46e5; /* Blue */
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 0 4px rgba(79, 70, 229, 0.3);
            transition: background-color 0.2s, box-shadow 0.2s;
        }
        input[type="range"]:hover::-webkit-slider-thumb {
            background-color: #4338ca; /* Darker blue on hover */
        }
        input[type="range"]:hover::-moz-range-thumb {
            background-color: #4338ca;
        }
        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 6px;
            background: #e5e7eb; /* Light gray track */
            border-radius: 3px;
        }
        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 3px;
        }
        /* Custom modal styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            transform: translateY(-50px);
            opacity: 0;
            animation: modal-fade-in 0.3s forwards ease-out;
        }
        .modal.hidden .modal-content {
            animation: modal-fade-out 0.3s forwards ease-in;
        }
        @keyframes modal-fade-in {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes modal-fade-out {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-50px); opacity: 0; }
        }

        /* Loading spinner */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .animate-spin {
            animation: spin 1s linear infinite;
        }
        /* Custom Message Box */
        #custom-message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #custom-message-box.show {
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-500 to-purple-600 min-h-screen flex items-center justify-center p-4">

    <!-- Main Player Section -->
    <div class="player-section">
        <h1 class="text-3xl font-bold text-gray-800 dark:text-white mb-4">TuneJam</h1>
        <div class="w-48 h-48 bg-gray-200 rounded-lg shadow-md flex items-center justify-center overflow-hidden mb-4">
            <img id="song-thumbnail" src="https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Track" alt="Song Thumbnail" class="w-full h-full object-cover">
            <div id="youtube-player" class="hidden"></div> <!-- YouTube player element -->
        </div>
        <h2 id="song-title" class="text-xl font-semibold text-gray-900 dark:text-white truncate w-full px-2">No song selected</h2>
        <p id="song-artist" class="text-md text-gray-600 dark:text-gray-400 mb-4 truncate w-full px-2"></p>

        <!-- Local Audio Player Controls (visible by default) -->
        <div id="local-player-controls" class="w-full flex flex-col gap-3">
            <div class="flex items-center justify-between w-full">
                <span id="current-time" class="text-sm text-gray-600 dark:text-gray-400">0:00</span>
                <input type="range" id="progress-bar" value="0" min="0" max="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mx-2">
                <span id="duration" class="text-sm text-gray-600 dark:text-gray-400">0:00</span>
            </div>
            <div class="flex items-center justify-center space-x-4">
                <button id="prev-btn" class="p-3 rounded-full bg-gray-200 hover:bg-gray-300 text-gray-700 transition-colors duration-200 shadow-md">
                    <i class="fas fa-backward"></i>
                </button>
                <button id="play-pause-btn" class="p-4 rounded-full bg-blue-600 hover:bg-blue-700 text-white transition-colors duration-200 shadow-lg transform hover:scale-105">
                    <i id="play-pause-icon" class="fas fa-play text-xl"></i>
                </button>
                <button id="next-btn" class="p-3 rounded-full bg-gray-200 hover:bg-gray-300 text-gray-700 transition-colors duration-200 shadow-md">
                    <i class="fas fa-forward"></i>
                </button>
            </div>
            <div class="flex items-center space-x-2 w-full">
                <i class="fas fa-volume-down text-gray-600 dark:text-gray-400"></i>
                <input type="range" id="volume-slider" value="100" min="0" max="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <i class="fas fa-volume-up text-gray-600 dark:text-gray-400"></i>
            </div>
        </div>

        <!-- YouTube Player Controls (hidden by default) -->
        <div id="youtube-player-controls" class="w-full flex-col gap-3 hidden">
            <div class="flex items-center justify-between w-full">
                <span id="youtube-current-time" class="text-sm text-gray-600 dark:text-gray-400">0:00</span>
                <input type="range" id="youtube-progress-bar" value="0" min="0" max="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer mx-2">
                <span id="youtube-duration" class="text-sm text-gray-600 dark:text-gray-400">0:00</span>
            </div>
            <div class="flex items-center justify-center space-x-4">
                <button id="youtube-prev-btn" class="p-3 rounded-full bg-gray-200 hover:bg-gray-300 text-gray-700 transition-colors duration-200 shadow-md">
                    <i class="fas fa-backward"></i>
                </button>
                <button id="youtube-play-pause-btn" class="p-4 rounded-full bg-blue-600 hover:bg-blue-700 text-white transition-colors duration-200 shadow-lg transform hover:scale-105">
                    <i id="youtube-play-pause-icon" class="fas fa-play text-xl"></i>
                </button>
                <button id="youtube-next-btn" class="p-3 rounded-full bg-gray-200 hover:bg-gray-300 text-gray-700 transition-colors duration-200 shadow-md">
                    <i class="fas fa-forward"></i>
                </button>
            </div>
            <div class="flex items-center space-x-2 w-full">
                <i class="fas fa-volume-down text-gray-600 dark:text-gray-400"></i>
                <input type="range" id="youtube-volume-slider" value="100" min="0" max="100" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <i class="fas fa-volume-up text-gray-600 dark:text-gray-400"></i>
            </div>
        </div>


        <!-- Jam Session Controls -->
        <div id="jam-controls" class="w-full bg-blue-50 p-4 rounded-lg shadow-inner hidden">
            <h3 class="text-lg font-bold text-blue-800 mb-2">Current Jam: <span id="jam-name-display"></span></h3>
            <p id="jam-id-display" class="text-sm text-blue-700 mb-3 truncate">Jam ID: Loading...</p>
            <div class="flex flex-col space-y-2">
                <button id="share-jam-link-btn" class="bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-200">
                    <i class="fas fa-share-alt mr-2"></i>Share Jam Link
                </button>
                <button id="copy-jam-id-btn" class="bg-blue-600 text-white py-2 px-4 rounded-lg hover:bg-blue-700 transition-colors duration-200">
                    <i class="fas fa-copy mr-2"></i>Copy Jam ID
                </button>
                <button id="leave-jam-btn" class="bg-red-500 text-white py-2 px-4 rounded-lg hover:bg-red-600 transition-colors duration-200">
                    <i class="fas fa-sign-out-alt mr-2"></i>Leave Jam
                </button>
            </div>
            <div class="mt-4">
                <h4 id="participants-count" class="text-md font-semibold text-blue-800 mb-2">Participants (0):</h4>
                <ul id="participants-list" class="text-sm text-blue-700 max-h-24 overflow-y-auto custom-scrollbar">
                    <!-- Participants will be listed here -->
                </ul>
            </div>
            <!-- Host Permissions Management Section -->
            <div id="permissions-management" class="mt-4 hidden">
                <h4 class="text-md font-semibold text-blue-800 mb-2">Manage Permissions:</h4>
                <div id="permissions-list" class="space-y-2">
                    <!-- Participant permissions will be dynamically rendered here by host -->
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="w-full flex flex-col space-y-3 mt-4">
            <button id="search-button" class="w-full bg-indigo-600 text-white py-3 rounded-lg font-semibold hover:bg-indigo-700 transition duration-300 transform hover:-translate-y-1 shadow-md">
                <i class="fas fa-search mr-2"></i>Search & Add Songs
            </button>
            <button id="play-random-hosted-songs-btn" class="w-full bg-green-500 text-white py-3 rounded-lg font-semibold hover:bg-green-600 transition duration-300 transform hover:-translate-y-1 shadow-md">
                <i class="fas fa-random mr-2"></i>Play Random Hosted MP3s
            </button>
            <div class="relative inline-block text-left w-full">
                <button id="create-jam-session-dropdown-btn" type="button" class="w-full bg-purple-600 text-white py-3 rounded-lg font-semibold hover:bg-purple-700 transition duration-300 transform hover:-translate-y-1 shadow-md focus:outline-none" aria-haspopup="true" aria-expanded="true">
                    <i class="fas fa-plus-circle mr-2"></i>Create Jam Session
                </button>
            </div>
            <div class="relative inline-block text-left w-full">
                <button id="join-jam-session-dropdown-btn" type="button" class="w-full bg-gray-700 text-white py-3 rounded-lg font-semibold hover:bg-gray-800 transition duration-300 transform hover:-translate-y-1 shadow-md focus:outline-none" aria-haspopup="true" aria-expanded="true">
                    <i class="fas fa-users mr-2"></i>Join Jam Session
                </button>
            </div>
        </div>
    </div>

    <!-- Playlist Section -->
    <div class="playlist-section">
        <h3 class="text-2xl font-bold text-gray-800 dark:text-white mb-4">Current Playlist</h3>
        <ul id="playlist-container" class="space-y-3 max-h-96 overflow-y-auto custom-scrollbar">
            <!-- Playlist items will be dynamically inserted here -->
        </ul>
    </div>

    <!-- Modals (Hidden by default) -->

    <!-- Search Modal -->
    <div id="search-modal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">Search Songs</h3>
                <button id="close-search-modal" class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
            </div>
            <input type="text" id="search-input" placeholder="Search by title or artist..." class="w-full p-3 border border-gray-300 rounded-lg mb-4 focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            
            <h4 class="text-lg font-semibold text-gray-800 mb-2">Hosted MP3s</h4>
            <div id="search-results" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar border rounded-lg p-2 mb-4">
                <!-- Search results for hosted MP3s will be loaded here -->
            </div>

            <h4 class="text-lg font-semibold text-gray-800 mb-2">YouTube Videos</h4>
            <div id="youtube-search-results-modal" class="space-y-2 max-h-48 overflow-y-auto custom-scrollbar border rounded-lg p-2">
                <!-- Search results for YouTube will be loaded here -->
            </div>
        </div>
    </div>

    <!-- Add Song Confirmation Modal -->
    <div id="add-song-modal" class="modal hidden">
        <div class="modal-content text-center">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">Add Song to Playlist?</h3>
                <button id="close-add-song-modal" class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
            </div>
            <img id="add-song-thumbnail" src="https://placehold.co/128x128/CCCCCC/FFFFFF?text=Song" alt="Song Thumbnail" class="w-24 h-24 rounded-md object-cover mx-auto mb-4 shadow-md">
            <h4 id="add-song-title" class="text-lg font-semibold text-gray-900 mb-1 truncate">Song Title</h4>
            <p id="add-song-artist" class="text-md text-gray-600 mb-4 truncate">Artist Name</p>
            <button id="confirm-add-song-btn" class="bg-blue-600 text-white py-2 px-6 rounded-lg font-semibold hover:bg-blue-700 transition duration-200">
                Confirm Add
            </button>
        </div>
    </div>

    <!-- Create Jam Session Modal -->
    <div id="create-jam-modal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">Create New Jam Session</h3>
                <button id="close-create-jam-modal" class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
            </div>
            <div class="mb-4">
                <label for="create-jam-name-input" class="block text-gray-700 text-sm font-medium mb-2">Jam Session Name</label>
                <input type="text" id="create-jam-name-input" placeholder="e.g., Chill Vibes" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>
            <div class="mb-4">
                <label for="create-jam-nickname-input" class="block text-gray-700 text-sm font-medium mb-2">Your Nickname</label>
                <input type="text" id="create-jam-nickname-input" placeholder="e.g., DJ Groove" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>
            <button id="create-jam-button" class="bg-purple-600 text-white py-3 rounded-lg font-semibold hover:bg-purple-700 transition duration-200 w-full">
                Create Jam
            </button>
            <div id="share-link-container" class="mt-6 p-3 bg-gray-100 border border-gray-200 rounded-lg hidden">
                <p class="text-sm font-medium text-gray-700 mb-2">Share this link to invite others:</p>
                <div class="flex items-center space-x-2">
                    <input type="text" id="jam-share-link" readonly
                           class="flex-grow px-3 py-2 bg-white border border-gray-300 rounded-md text-sm text-gray-700 truncate">
                    <button id="copy-share-link-button" class="px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors duration-200">
                        <i class="fas fa-copy"></i> Copy
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Join Jam Session Modal -->
    <div id="join-jam-modal" class="modal hidden">
        <div class="modal-content">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-gray-800">Join Existing Jam Session</h3>
                <button id="close-join-jam-modal" class="text-gray-500 hover:text-gray-700 text-2xl font-bold">&times;</button>
            </div>
            <p id="join-jam-name-display" class="text-lg text-center text-indigo-600 font-semibold mb-4"></p>
            <div class="mb-4">
                <label for="join-jam-id-input" class="block text-gray-700 text-sm font-medium mb-2">Jam ID</label>
                <input type="text" id="join-jam-id-input" placeholder="Enter Jam ID" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>
            <div class="mb-4">
                <label for="join-jam-nickname-input" class="block text-gray-700 text-sm font-medium mb-2">Your Nickname</label>
                <input type="text" id="join-jam-nickname-input" placeholder="e.g., Music Lover" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
            </div>
            <button id="join-jam-button" class="bg-gray-700 text-white py-3 rounded-lg font-semibold hover:bg-gray-800 transition duration-200 w-full">
                Join Jam
            </button>
        </div>
    </div>

    <!-- Global Message Modal -->
    <div id="message-modal" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
            <p id="modal-message" class="text-lg font-semibold mb-4"></p>
            <button id="modal-ok-button" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
                OK
            </button>
        </div>
    </div>

    <!-- Confirmation Modal (NEW) -->
    <div id="confirmation-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="confirmation-modal-title" class="text-xl font-bold text-gray-800 mb-4 text-center"></h3>
            <p id="confirmation-modal-message" class="text-gray-700 mb-6 text-center"></p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-yes-btn" class="bg-red-500 text-white py-2 px-6 rounded-lg hover:bg-red-600 transition-colors duration-200">Yes</button>
                <button id="confirm-no-btn" class="bg-gray-300 text-gray-800 py-2 px-6 rounded-lg hover:bg-gray-400 transition-colors duration-200">No</button>
            </div>
        </div>
    </div>


    <script type="module">
        // Globally accessible Firebase instances (initialized in the script tag above)
        const db = window.firebaseDb;
        const auth = window.firebaseAuth;
        const doc = window.firebaseDoc;
        const onSnapshot = window.firebaseOnSnapshot;
        const getDoc = window.firebaseGetDoc;
        const setDoc = window.firebaseSetDoc;
        const updateDoc = window.firebaseUpdateDoc;
        const deleteDoc = window.firebaseDeleteDoc;
        const collection = window.firebaseCollection;
        const signInAnonymously = window.firebaseSignInAnonymously;
        const onAuthStateChanged = window.firebaseOnAuthStateChanged;
        const signInWithCustomToken = window.firebaseSignInWithCustomToken;


        const FLASK_BACKEND_URL = 'http://localhost:5000'; // Set to 'http://localhost:5000' for local, '' for Vercel

        // IMPORTANT: Replace 'YOUR_TELUGU_SONGS_DRIVE_FOLDER_ID_HERE' with your actual Google Drive Folder ID
        const PUBLIC_TELUGU_SONGS_FOLDER_ID = '1zBAeBpuMNmnqEGxPJtBn5MS0m8p2SOob';

        // Socket.IO setup (still used for direct signaling, but Firestore is source of truth for state)
        const socket = io(FLASK_BACKEND_URL); 
        
        let currentJamId = null;
        let isHost = false;
        let myNickname = '';
        let jamSessionPlaylist = []; // The playlist used in the jam session, synchronized from Firestore
        let jamSessionParticipants = {}; // Participants in the current jam session {sid: {nickname: '...', permissions: {}}}
        let unsubscribeJamListener = null; // To unsubscribe from Firestore snapshot listener
        let myPermissions = { play: false, add: false, remove: false }; // Current client's permissions

        // Global YouTube Player variable
        let youtubePlayer;
        let youtubePlayerReady = false;

        let isPlayingRandomHostedMode = false; // Renamed to align with HTML for hosted MP3s
        let fullHostedSongsList = []; // Renamed to align with HTML for hosted MP3s
        const INITIAL_RANDOM_QUEUE_SIZE = 10; // Renamed to align with HTML for hosted MP3s


        // --- DOM Elements ---
        const audioPlayer = document.getElementById('audio-player'); // Removed 'audio-' prefix from HTML ID in previous version, matching here
        const playPauseButton = document.getElementById('play-pause-btn'); // Matched ID with current HTML
        const playPauseIcon = document.getElementById('play-pause-icon'); // Matched ID with current HTML
        const progressBar = document.getElementById('progress-bar');
        const currentTimeSpan = document.getElementById('current-time');
        const totalTimeSpan = document.getElementById('duration'); // Matched ID with current HTML
        const volumeSlider = document.getElementById('volume-slider'); // Matched ID with current HTML
        const prevBtn = document.getElementById('prev-btn'); // Matched ID with current HTML
        const nextBtn = document.getElementById('next-btn'); // Matched ID with current HTML
        const songTitleSpan = document.getElementById('song-title'); // Matched ID with current HTML
        const songArtistSpan = document.getElementById('song-artist'); // Matched ID with current HTML
        const songThumbnailImg = document.getElementById('song-thumbnail'); // Matched ID with current HTML
        const youtubePlayerDiv = document.getElementById('youtube-player'); // Matched ID with current HTML

        const localPlayerControls = document.getElementById('local-player-controls');
        const youtubePlayerControls = document.getElementById('youtube-player-controls');
        const youtubeProgressBar = document.getElementById('youtube-progress-bar');
        const youtubeCurrentTimeSpan = document.getElementById('youtube-current-time');
        const youtubeDurationSpan = document.getElementById('youtube-duration');
        const youtubeVolumeSlider = document.getElementById('youtube-volume-slider');
        const youtubePlayPauseBtn = document.getElementById('youtube-play-pause-btn');
        const youtubePlayPauseIcon = document.getElementById('youtube-play-pause-icon');
        const youtubePrevBtn = document.getElementById('youtube-prev-btn');
        const youtubeNextBtn = document.getElementById('youtube-next-btn');


        const playlistContainer = document.getElementById('playlist-container');

        // Buttons and Dropdowns
        const searchButton = document.getElementById('search-button'); // Main search button
        const searchInput = document.getElementById('search-input'); // Search input in search modal
        const searchResultsContainer = document.getElementById('search-results'); // Hosted MP3 search results
        const youtubeSearchResultsModal = document.getElementById('youtube-search-results-modal'); // YouTube search results in modal
        const closeSearchModalBtn = document.getElementById('close-search-modal');
        const searchModal = document.getElementById('search-modal');
        const addSongModal = document.getElementById('add-song-modal');
        const closeAddSongModalBtn = document.getElementById('close-add-song-modal');
        const addSongTitle = document.getElementById('add-song-title');
        const addSongArtist = document.getElementById('add-song-artist');
        const addSongThumbnail = document.getElementById('add-song-thumbnail');
        const confirmAddSongBtn = document.getElementById('confirm-add-song-btn');


        const managePlaylistButton = document.getElementById('manage-playlist-button');
        const playRandomHostedSongsButton = document.getElementById('play-random-hosted-songs-btn'); // Matched ID with current HTML

        // Modals
        const youtubeModal = document.getElementById('youtube-modal'); // YouTube modal - renamed in current HTML, using this
        const managePlaylistModal = document.getElementById('manage-playlist-modal');

        // Removed Google Drive search from main section, using searchModal now.
        const addOptionsContainer = document.getElementById('add-options-container'); // This refers to Google Drive search section from old code
        // This is now redundant as 'Search & Add Songs' button is primary. It should be hidden.
        if (addOptionsContainer) addOptionsContainer.classList.add('hidden'); 

        const openOptionsDropdownButton = document.getElementById('open-options-dropdown-button'); // This button is not in current HTML, removing logic for it
        const optionsDropdown = document.getElementById('options-dropdown'); // This dropdown is not in current HTML, removing logic for it
        // These elements are from the old code, which the user provided.
        // In the new `index-html-permissions` HTML, the 'Add Songs' button is directly search-button.
        // The three dots dropdown was replaced by direct 'Create Jam Session' and 'Join Jam Session' buttons.
        // So, the `openOptionsDropdownButton`, `optionsDropdown`, `addYoutubeSongDropdown` are NOT in the current HTML.
        // The HTML provided in the selection tag has direct buttons:
        // `create-jam-session-dropdown-btn` and `join-jam-session-dropdown-btn`
        // I will keep the original IDs as per the provided HTML.

        const createJamSessionDropdownBtn = document.getElementById('create-jam-session-dropdown-btn');
        const joinJamSessionDropdownBtn = document.getElementById('join-jam-session-dropdown-btn');

        
        // Elements within YouTube Modal (as per selected HTML)
        const youtubeUrlInputModal = document.getElementById('youtube-url-input-modal');
        const addFromUrlButton = document.getElementById('add-from-url-button');
        const youtubeTextSearchInput = document.getElementById('youtube-text-search-input');
        const performYoutubeTextSearchButton = document.getElementById('perform-youtube-text-search');
        const youtubeSearchResults = document.getElementById('youtube-search-results');
        
        const editablePlaylistContainer = document.getElementById('editable-playlist-container');
        const playlistEmptyMessage = document.getElementById('playlist-empty-message');

        // Jam Session Modals and Elements (as per selected HTML)
        const createJamModal = document.getElementById('create-jam-modal');
        const createJamNameInput = document.getElementById('create-jam-name-input'); // Renamed to match selected HTML
        const createJamNicknameInput = document.getElementById('create-jam-nickname-input'); // Renamed to match selected HTML
        const createJamButton = document.getElementById('create-jam-button');
        const shareLinkContainer = document.getElementById('share-link-container');
        const jamShareLinkInput = document.getElementById('jam-share-link');
        const copyShareLinkButton = document.getElementById('copy-share-link-button');

        const joinJamModal = document.getElementById('join-jam-modal');
        const joinJamNameDisplay = document.getElementById('join-jam-name-display');
        const joinJamIdInput = document.getElementById('join-jam-id-input'); // Matched ID with current HTML
        const joinJamNicknameInput = document.getElementById('join-jam-nickname-input'); // Matched ID with current HTML
        const joinJamButton = document.getElementById('join-jam-button');

        const jamControlsDiv = document.getElementById('jam-controls'); // Matched ID with current HTML
        const jamIdDisplay = document.getElementById('jam-id-display'); // Matched ID with current HTML
        const jamNameDisplay = document.getElementById('jam-name-display'); // Matched ID with current HTML
        const participantsList = document.getElementById('participants-list'); // Matched ID with current HTML
        const shareJamLinkButton = document.getElementById('share-jam-link-btn'); // Matched ID with current HTML
        const copyJamIdButton = document.getElementById('copy-jam-id-btn'); // Matched ID with current HTML
        const leaveJamButton = document.getElementById('leave-jam-btn'); // Matched ID with current HTML
        const participantsCount = document.getElementById('participants-count'); // Matched ID with current HTML

        const permissionsManagementDiv = document.getElementById('permissions-management'); // New
        const permissionsList = document.getElementById('permissions-list'); // New

        const messageModal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const modalOkButton = document.getElementById('modal-ok-button');

        // Confirmation Modal elements (NEW)
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationModalTitle = document.getElementById('confirmation-modal-title');
        const confirmationModalMessage = document.getElementById('confirmation-modal-message');
        const confirmYesBtn = document.getElementById('confirm-yes-btn');
        const confirmNoBtn = document.getElementById('confirm-no-btn');


        const playlist = []; // Main player local playlist. This is only used when NOT in a jam session.

        let currentTrackIndex = 0;
        let progressInterval;
        let syncInterval; // For host to send regular updates to Firestore

        let userId = null; // Firebase User ID
        let currentPlaybackTime = 0; // To store and sync playback time
        let isSeeking = false; // Flag to prevent sync during seeking


        // --- Firebase Auth Listener (New) ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                console.log("Firebase authenticated. User ID:", userId);
                // Now that we have a user, proceed with app initialization or jam session logic
                handleInitialLoadAndJamJoin();

            } else {
                console.log("Firebase not authenticated. Signing in anonymously...");
                signInAnonymously(auth).then(() => {
                    console.log("Signed in anonymously.");
                }).catch((error) => {
                    console.error("Anonymous sign-in failed:", error);
                    showMessage(`Authentication failed: ${error.message}. Jam features may not work.`, 6000);
                    // Disable jam features on critical Firebase auth failure
                    createJamSessionDropdownBtn.disabled = true;
                    createJamSessionDropdownBtn.classList.add('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                    joinJamSessionDropdownBtn.disabled = true;
                    joinJamSessionDropdownBtn.classList.add('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                });
            }
        });


        // --- Utility Functions ---
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0) return "0:00";
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showMessage(message, duration = 3000) {
            const msgBox = document.getElementById('custom-message-box');
            msgBox.textContent = message;
            msgBox.classList.remove('hidden');
            msgBox.classList.add('show');
            clearTimeout(msgBox.messageTimeout); // Clear any existing timeout
            msgBox.messageTimeout = setTimeout(() => {
                msgBox.classList.remove('show');
                msgBox.classList.add('hidden');
            }, duration);
        }

        function showLoading() {
            document.getElementById('loading-overlay').classList.remove('hidden');
        }

        function hideLoading() {
            document.getElementById('loading-overlay').classList.add('hidden');
        }

        function extractYouTubeVideoId(url) {
            let videoId = '';
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/i;
            const match = url.match(youtubeRegex);
            if (match && match[1]) {
                videoId = match[1];
            }
            return videoId;
        }

        // Custom Confirmation Dialog (NEW)
        function showConfirmation(title, message, onConfirm) {
            confirmationModalTitle.textContent = title;
            confirmationModalMessage.textContent = message;
            confirmationModal.classList.remove('hidden');

            const handleYes = () => {
                confirmationModal.classList.add('hidden');
                confirmYesBtn.removeEventListener('click', handleYes);
                confirmNoBtn.removeEventListener('click', handleNo);
                onConfirm(true);
            };

            const handleNo = () => {
                confirmationModal.classList.add('hidden');
                confirmYesBtn.removeEventListener('click', handleYes);
                confirmNoBtn.removeEventListener('click', handleNo);
                onConfirm(false);
            };

            confirmYesBtn.addEventListener('click', handleYes);
            confirmNoBtn.addEventListener('click', handleNo);
        }


        // --- YouTube API Integration ---
        function loadYouTubeAPI() {
            const tag = document.createElement('script');
            tag.src = "https://www.youtube.com/iframe_api";
            const firstScriptTag = document.getElementsByTagName('script')[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
        }

        window.onYouTubeIframeAPIReady = function() {
            youtubePlayer = new YT.Player('youtube-player', { // Using 'youtube-player' div directly
                height: '100%', // Set to 100% to fill container
                width: '100%',  // Set to 100% to fill container
                videoId: '',
                playerVars: {
                    'playsinline': 1,
                    'autoplay': 0, // Autoplay set to 0 to prevent issues
                    'controls': 0,
                    'disablekb': 1,
                    'fs': 0,
                    'iv_load_policy': 3,
                    'modestbranding': 1,
                    'rel': 0,
                    'showinfo': 0,
                    'start': 0
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        }

        function onPlayerReady(event) {
            youtubePlayerReady = true;
            console.log("YouTube Player is ready.");
            if (currentJamId && jamSessionPlaylist.length > 0) {
                // If in a jam session and YouTube player becomes ready, re-sync to current track
                // The onSnapshot listener will handle the actual playback synchronization.
            } else if (!currentJamId && playlist.length > 0 && playlist[currentTrackIndex] && playlist[currentTrackIndex].type === 'youtube') {
                 // If not in a jam, try to load current local youtube track, but don't autoplay
                loadTrack(currentTrackIndex, false); 
            }
        }

        function onPlayerStateChange(event) {
            // Check if player is actually paused/playing before emitting
            const isCurrentlyPlaying = (event.data === YT.PlayerState.PLAYING);
            const isCurrentlyPaused = (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED);

            if (isCurrentlyPlaying) {
                youtubePlayPauseIcon.classList.remove('fa-play');
                youtubePlayPauseIcon.classList.add('fa-pause');
                //playPauseButton.classList.add('is-playing'); // This is for local player
                clearInterval(progressInterval);
                progressInterval = setInterval(updateProgressBar, 1000);
            } else if (isCurrentlyPaused) {
                youtubePlayPauseIcon.classList.remove('fa-pause');
                youtubePlayPauseIcon.classList.add('fa-play');
                //playPauseButton.classList.remove('is-playing'); // This is for local player
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    if (!currentJamId || isHost || myPermissions.play) { // Ensure play permission or host
                        playNextTrack(); // Host or local player controls next track
                    }
                }
            }
            if (currentJamId && isHost) {
                // Host updates Firestore whenever playback state changes
                updateFirestorePlaybackState();
            }
        }

        function onPlayerError(event) {
            console.error("YouTube Player Error:", event.data);
            showMessage(`YouTube playback error (${event.data}). Skipping to next song.`, 4000);
            if (!currentJamId || isHost || myPermissions.play) { // Ensure play permission or host
                playNextTrack(); // Host or local player controls next track
            }
        }

        // --- Core Player Functions ---
        async function loadTrack(index, autoPlay = true) {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;

            if (index < 0 || index >= activePlaylist.length) {
                console.warn("Invalid track index or playlist is empty.");
                resetPlayerUI();
                return;
            }

            // Remove 'current-song' class from all playlist items
            const currentActive = document.querySelector('.playlist-item.current-song');
            if (currentActive) {
                currentActive.classList.remove('current-song');
            }

            currentTrackIndex = index;
            const track = activePlaylist[currentTrackIndex];

            songTitleSpan.textContent = track.title;
            songArtistSpan.textContent = track.artist || track.uploader || 'Unknown Artist';
            songThumbnailImg.src = track.thumbnail || "https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Track";
            songThumbnailImg.onerror = () => {
                songThumbnailImg.src = "https://placehold.co/128x128/CCCCCC/FFFFFF?text=Error";
            };

            // Ensure only one player UI is visible
            localPlayerControls.classList.add('hidden');
            youtubePlayerControls.classList.add('hidden');
            youtubePlayerDiv.classList.add('hidden'); // Hide YouTube iframe div
            songThumbnailImg.classList.remove('hidden'); // Show static thumbnail by default

            audioPlayer.pause(); // Pause HTML audio before loading new source
            if (youtubePlayer && youtubePlayerReady) youtubePlayer.pauseVideo(); // Pause YouTube video

            if (track.type === 'audio') { // 'audio' type for hosted MP3s
                localPlayerControls.classList.remove('hidden');
                audioPlayer.src = track.url; // Use 'url' for hosted MP3s
                audioPlayer.load();
                if (autoPlay) {
                    audioPlayer.play().catch(e => console.error("Error playing audio (type:audio):", e));
                    playPauseIcon.classList.remove('fa-play');
                    playPauseIcon.classList.add('fa-pause');
                } else {
                    playPauseIcon.classList.remove('fa-pause');
                    playPauseIcon.classList.add('fa-play');
                }
                clearInterval(progressInterval);
                progressInterval = setInterval(updateProgressBar, 1000);

            } else if (track.type === 'youtube') {
                youtubePlayerControls.classList.remove('hidden');
                songThumbnailImg.classList.add('hidden'); // Hide static thumbnail
                youtubePlayerDiv.classList.remove('hidden'); // Show YouTube iframe div

                if (youtubePlayerReady) {
                    youtubePlayer.loadVideoById(track.videoId, 0); // Load and play from start
                    if (autoPlay) {
                        youtubePlayer.playVideo();
                        youtubePlayPauseIcon.classList.remove('fa-play');
                        youtubePlayPauseIcon.classList.add('fa-pause');
                    } else {
                        youtubePlayer.pauseVideo(); // Ensure it's paused if not auto-playing
                        youtubePlayPauseIcon.classList.remove('fa-pause');
                        youtubePlayPauseIcon.classList.add('fa-play');
                    }
                } else {
                    console.warn("YouTube player not ready, cannot play video yet.");
                    showMessage("YouTube player is still loading. Please try again in a moment.", 3000);
                    youtubePlayPauseIcon.classList.remove('fa-pause');
                    youtubePlayPauseIcon.classList.add('fa-play');
                }
            } else {
                console.warn("Unknown track type:", track.type);
                showMessage("Unsupported track type. Skipping.", 3000);
                if (!currentJamId || isHost || myPermissions.play) { // Ensure play permission or host
                    playNextTrack(); // Skip unsupported track
                }
                return;
            }
            
            // Add 'current-song' class to the newly active playlist item
            const newActive = document.getElementById(`playlist-item-${index}`);
            if (newActive) {
                newActive.classList.add('current-song');
            }
        }

        // --- Audio Player Event Handlers (Local MP3s) ---
        audioPlayer.addEventListener('timeupdate', () => {
            if (!isSeeking) {
                progressBar.value = (audioPlayer.currentTime / audioPlayer.duration) * 100;
                currentTimeSpan.textContent = formatTime(audioPlayer.currentTime);
                totalTimeSpan.textContent = formatTime(audioPlayer.duration);
            }
        });

        audioPlayer.addEventListener('ended', () => {
            if (!currentJamId || isHost || myPermissions.play) {
                playNextTrack();
            }
        });

        audioPlayer.addEventListener('play', () => {
            // Handled by playTrack or togglePlayPause
        });

        audioPlayer.addEventListener('pause', () => {
            // Handled by playTrack or togglePlayPause
        });

        audioPlayer.addEventListener('volumechange', () => {
            volumeSlider.value = audioPlayer.volume * 100;
        });

        // --- YouTube Player Event Handlers ---
        // onPlayerReady, onPlayerStateChange, onPlayerError are defined above in the global scope `window.onYouTubeIframeAPIReady`

        function updateProgressBar() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];
            if (!currentTrack) return;

            let progress = 0;
            let duration = 0;
            let currentTime = 0;

            if (currentTrack.type === 'audio') {
                currentTime = audioPlayer.currentTime;
                duration = audioPlayer.duration;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                currentTime = youtubePlayer.getCurrentTime();
                duration = youtubePlayer.getDuration();
            }

            if (duration > 0 && isFinite(duration)) {
                progress = (currentTime / duration) * 100;
            }

            progressBar.value = progress;
            youtubeProgressBar.value = progress;
            currentTimeSpan.textContent = formatTime(currentTime);
            totalTimeSpan.textContent = formatTime(duration);
            youtubeCurrentTimeSpan.textContent = formatTime(currentTime);
            youtubeDurationSpan.textContent = formatTime(duration);
        }

        // --- Playback Controls ---
        playPauseButton.addEventListener('click', togglePlayPause);
        youtubePlayPauseBtn.addEventListener('click', togglePlayPause);

        function togglePlayPause() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            if (!currentTrack) {
                showMessage("Playlist is empty. Add songs first!", 3000);
                return;
            }

            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }

            let newIsPlaying;
            if (currentTrack.type === 'audio') {
                if (audioPlayer.paused) {
                    audioPlayer.play().catch(e => console.error("Error playing audio:", e));
                    newIsPlaying = true;
                } else {
                    audioPlayer.pause();
                    newIsPlaying = false;
                }
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                if (youtubePlayer.getPlayerState() === YT.PlayerState.PAUSED || youtubePlayer.getPlayerState() === YT.PlayerState.ENDED || youtubePlayer.getPlayerState() === YT.PlayerState.BUFFERING) {
                    youtubePlayer.playVideo();
                    newIsPlaying = true;
                } else {
                    youtubePlayer.pauseVideo();
                    newIsPlaying = false;
                }
            } else {
                showMessage("Unsupported track type.", 3000);
                return;
            }

            if (currentJamId && isHost) {
                updateFirestorePlaybackState(newIsPlaying); // Sync state after host action
            }
        }

        prevBtn.addEventListener('click', playPrevTrack);
        youtubePrevBtn.addEventListener('click', playPrevTrack);

        function playPrevTrack() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            if (activePlaylist.length === 0) {
                showMessage("Playlist is empty. Cannot go back.", 2000);
                return;
            }

            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }

            currentTrackIndex = (currentTrackIndex - 1 + activePlaylist.length) % activePlaylist.length;
            loadTrack(currentTrackIndex, true);
            if (currentJamId && isHost) {
                updateFirestorePlaybackState(true, currentTrackIndex, 0);
            }
        }

        nextBtn.addEventListener('click', playNextTrack);
        youtubeNextBtn.addEventListener('click', playNextTrack);

        function playNextTrack() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            if (activePlaylist.length === 0) {
                resetPlayerUI();
                showMessage("Playlist is empty.", 3000);
                return;
            }

            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }

            if (isPlayingRandomHostedMode) {
                // If in random mode, replace current song and get a new random one
                const currentSongId = activePlaylist[currentTrackIndex]?.id;
                const indexToRemove = activePlaylist.findIndex(song => song.id === currentSongId);

                if (indexToRemove !== -1) {
                    activePlaylist.splice(indexToRemove, 1); // Remove the just played song
                }

                // Add a new random song if available
                const newRandomSong = getUniqueRandomHostedSong(1, true); // Get one new song and add to end
                if (newRandomSong.length === 0) {
                    showMessage("No more unique random songs to add. Re-shuffling pool.", 3000);
                    fullHostedSongsList = []; // Reset full list to allow re-selection
                    getUniqueRandomHostedSong(INITIAL_RANDOM_QUEUE_SIZE); // Re-populate for next time
                }

                currentTrackIndex = 0; // Always play the first song in the shuffled queue
                loadTrack(currentTrackIndex, true);

                if (currentJamId && isHost) {
                    updateFirestorePlaybackState(true, currentTrackIndex, 0); // Update Firestore
                }
            } else {
                let nextIndex = currentTrackIndex + 1;
                if (nextIndex >= activePlaylist.length) {
                    nextIndex = 0; // Loop back to the beginning
                }
                loadTrack(nextIndex, true);
                if (currentJamId && isHost) {
                    updateFirestorePlaybackState(true, nextIndex, 0);
                }
            }
        }


        volumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            audioPlayer.volume = volume;
            if (youtubePlayerReady) {
                youtubePlayer.setVolume(volume * 100); // YouTube API uses 0-100
            }
        });
        
        youtubeVolumeSlider.addEventListener('input', (e) => {
            const volume = e.target.value / 100;
            audioPlayer.volume = volume; // Sync local player volume
            if (youtubePlayerReady) {
                youtubePlayer.setVolume(volume * 100); // YouTube API uses 0-100
            }
        });


        function isMediaReadyForSeek() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];
            if (!currentTrack) {
                showMessage("No song loaded.", 2000);
                return false;
            }

            let mediaDuration = 0;
            let ready = false;

            if (currentTrack.type === 'audio') {
                if (audioPlayer.readyState >= 3) {
                    mediaDuration = audioPlayer.duration;
                    ready = !isNaN(mediaDuration) && isFinite(mediaDuration) && mediaDuration > 0;
                }
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                const playerState = youtubePlayer.getPlayerState();
                if (playerState !== YT.PlayerState.BUFFERING && playerState !== YT.PlayerState.UNSTARTED) {
                    mediaDuration = youtubePlayer.getDuration();
                    ready = !isNaN(mediaDuration) && isFinite(mediaDuration) && mediaDuration > 0;
                }
            }
            if (!ready) {
                console.warn("Media not ready for seek/jump. Current duration:", mediaDuration);
                showMessage("Media is still loading. Please wait.", 2000);
            }
            return ready;
        }

        progressBar.addEventListener('mousedown', () => isSeeking = true);
        progressBar.addEventListener('mouseup', (e) => {
            isSeeking = false;
            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }
            if (!isMediaReadyForSeek()) { return; }

            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            let player;
            let totalDuration;

            if (currentTrack.type === 'audio') {
                player = audioPlayer;
                totalDuration = audioPlayer.duration;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                player = youtubePlayer;
                totalDuration = youtubePlayer.getDuration();
            } else { return; }

            const seekTime = (e.target.value / 100) * totalDuration;
            if (currentTrack.type === 'audio') {
                player.currentTime = seekTime;
            } else {
                player.seekTo(seekTime, true);
            }
            if (currentJamId && isHost) {
                updateFirestorePlaybackState(); // Sync state after host action
            }
        });
        progressBar.addEventListener('input', updateProgressBar); // Update time display during seek

        youtubeProgressBar.addEventListener('mousedown', () => isSeeking = true);
        youtubeProgressBar.addEventListener('mouseup', (e) => {
            isSeeking = false;
            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }
            if (!isMediaReadyForSeek()) { return; }

            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            let player;
            let totalDuration;

            if (currentTrack.type === 'audio') {
                player = audioPlayer;
                totalDuration = audioPlayer.duration;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                player = youtubePlayer;
                totalDuration = youtubePlayer.getDuration();
            } else { return; }

            const seekTime = (e.target.value / 100) * totalDuration;
            if (currentTrack.type === 'audio') {
                player.currentTime = seekTime;
            } else {
                player.seekTo(seekTime, true);
            }
            if (currentJamId && isHost) {
                updateFirestorePlaybackState(); // Sync state after host action
            }
        });
        youtubeProgressBar.addEventListener('input', updateProgressBar); // Update time display during seek


        // --- Search Functionality ---
        searchButton.addEventListener('click', () => {
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to add songs to this jam.", 3000);
                return;
            }
            searchModal.classList.remove('hidden');
        });

        closeSearchModalBtn.addEventListener('click', () => {
            searchModal.classList.add('hidden');
            searchResultsContainer.innerHTML = ''; // Clear previous results
            youtubeSearchResultsModal.innerHTML = ''; // Clear YouTube results
            searchInput.value = ''; // Clear search input
        });

        searchInput.addEventListener('input', debounce(performSearch, 300)); // Debounce search input

        async function performSearch() {
            const query = searchInput.value.trim();
            if (query.length < 2) {
                searchResultsContainer.innerHTML = '';
                youtubeSearchResultsModal.innerHTML = '';
                return;
            }

            searchResultsContainer.innerHTML = '<p class="text-gray-500 text-center py-4">Searching local MP3s...</p>';
            youtubeSearchResultsModal.innerHTML = '<p class="text-gray-500 text-center py-4">Searching YouTube...</p>';

            try {
                // Search hosted MP3s
                const hostedResponse = await fetch(`${FLASK_BACKEND_URL}/search_hosted_mp3s?query=${encodeURIComponent(query)}`);
                const hostedSongs = await hostedResponse.json();
                renderSearchResults(hostedSongs, searchResultsContainer, 'audio');

                // Search YouTube
                const youtubeResponse = await fetch(`${FLASK_BACKEND_URL}/Youtube?query=${encodeURIComponent(query)}`);
                const youtubeVideos = await youtubeResponse.json();
                renderSearchResults(youtubeVideos, youtubeSearchResultsModal, 'youtube');

            } catch (error) {
                console.error("Search error:", error);
                searchResultsContainer.innerHTML = '<p class="text-red-500 text-center py-4">Error searching local MP3s.</p>';
                youtubeSearchResultsModal.innerHTML = '<p class="text-red-500 text-center py-4">Error searching YouTube.</p>';
                showMessage("Failed to perform search. Please try again.");
            }
        }

        function renderSearchResults(results, container, type) {
            container.innerHTML = '';
            if (results.length === 0) {
                container.innerHTML = `<p class="text-gray-500 text-center py-4">No ${type} results found.</p>`;
                return;
            }

            results.forEach(item => {
                const div = document.createElement('div');
                div.className = 'flex items-center justify-between p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-700 cursor-pointer';
                div.innerHTML = `
                    <div class="flex items-center space-x-3 flex-grow">
                        <img src="${item.thumbnail || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=Thumb'}" alt="Thumbnail" class="w-10 h-10 rounded-md object-cover shadow-sm">
                        <div class="flex-grow">
                            <h4 class="text-sm font-medium text-gray-800 dark:text-white truncate">${item.title}</h4>
                            <p class="text-xs text-gray-500 dark:text-gray-400 truncate">${item.artist || item.uploader || 'Unknown'}</p>
                        </div>
                    </div>
                    <button class="add-to-playlist-btn ml-2 p-2 rounded-full bg-blue-500 text-white hover:bg-blue-600 transition-colors duration-200">
                        <i class="fas fa-plus"></i>
                    </button>
                `;
                div.querySelector('.add-to-playlist-btn').addEventListener('click', () => {
                    prepareAddSong(item, type);
                });
                container.appendChild(div);
            });
        }

        function debounce(func, delay) {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), delay);
            };
        }

        function prepareAddSong(song, type) {
            selectedSongForAdd = { ...song, type: type }; // Store selected song with its type
            addSongTitle.textContent = song.title;
            addSongArtist.textContent = song.artist || song.uploader || 'Unknown Artist';
            addSongThumbnail.src = song.thumbnail || 'https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Image';
            addSongModal.classList.remove('hidden');
        }

        closeAddSongModalBtn.addEventListener('click', () => {
            addSongModal.classList.add('hidden');
            selectedSongForAdd = null;
        });

        confirmAddSongBtn.addEventListener('click', () => {
            if (selectedSongForAdd) {
                addSongToCurrentPlaylist(selectedSongForAdd);
                addSongModal.classList.add('hidden');
                searchModal.classList.add('hidden'); // Close search modal after adding
                searchResultsContainer.innerHTML = '';
                youtubeSearchResultsModal.innerHTML = '';
                searchInput.value = '';
            }
        });

        async function addSongToCurrentPlaylist(song) {
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to add songs to this jam.", 3000);
                return;
            }

            let newSong = { ...song }; // Create a copy to modify if needed

            if (currentJamId) {
                // If in a jam, send to server to add to shared playlist
                if (socket) {
                    // Assign a unique ID if missing
                    if (!newSong.id) {
                        newSong.id = 'song_' + Date.now() + Math.random().toString(36).substring(2, 9);
                    }
                    socket.emit('add_song_to_jam', { jam_id: currentJamId, song: newSong });
                } else {
                    showMessage("Not connected to jam session. Cannot add song.");
                }
            } else {
                // If not in a jam, add to local playlist
                // Assign a unique ID if missing
                if (!newSong.id) {
                    newSong.id = 'song_' + Date.now() + Math.random().toString(36).substring(2, 9);
                }
                playlist.push(newSong);
                showMessage(`Added "${newSong.title}" to your local playlist.`);
            }
            renderPlaylist();
            isPlayingRandomHostedMode = false; // Turn off random mode if user adds a specific song
        }

        function removeSongFromJam(songId) {
            if (currentJamId && !isHost && !myPermissions.remove) {
                showMessage("You do not have permission to remove songs from this jam.", 3000);
                return;
            }
            if (socket) {
                socket.emit('remove_song_from_jam', { jam_id: currentJamId, song_id: songId });
            } else {
                showMessage("Not connected to jam session.", 3000);
            }
        }


        // --- Jam Session UI Controls ---
        createJamSessionDropdownBtn.addEventListener('click', () => {
            createJamModal.classList.remove('hidden');
        });

        joinJamSessionDropdownBtn.addEventListener('click', () => {
            joinJamModal.classList.remove('hidden');
        });

        // Close buttons for modals
        document.querySelector('#create-jam-modal .modal-close-button').addEventListener('click', () => createJamModal.classList.add('hidden'));
        document.querySelector('#join-jam-modal .modal-close-button').addEventListener('click', () => joinJamModal.classList.add('hidden'));
        document.querySelector('#youtube-modal .modal-close-button').addEventListener('click', () => youtubeModal.classList.add('hidden'));
        document.querySelector('#manage-playlist-modal .modal-close-button').addEventListener('click', () => managePlaylistModal.classList.add('hidden'));


        createJamButton.addEventListener('click', () => {
            const jamName = createJamNameInput.value.trim();
            const nickname = createJamNicknameInput.value.trim() || 'Host';
            if (jamName && socket) {
                socket.emit('create_session', { jam_name: jamName, nickname: nickname });
                createJamModal.classList.add('hidden');
            } else {
                showMessage("Please enter a jam name and ensure you are connected.", 3000);
            }
        });

        joinJamButton.addEventListener('click', () => {
            const enteredJamId = joinJamIdInput.value.trim();
            const nickname = joinJamNicknameInput.value.trim() || 'Guest';
            if (enteredJamId && socket) {
                socket.emit('join_session', { jam_id: enteredJamId, nickname: nickname });
                joinJamModal.classList.add('hidden');
            } else {
                showMessage("Please enter a Jam ID and ensure you are connected.", 3000);
            }
        });

        shareJamLinkButton.addEventListener('click', () => {
            if (currentJamId) {
                const shareableLink = `${window.location.origin}/join/${currentJamId}`;
                
                navigator.clipboard.writeText(shareableLink).then(() => {
                    showMessage("Shareable link copied to clipboard!", 2000);
                }).catch(err => {
                    console.error('Failed to copy text using navigator.clipboard:', err);
                    // Fallback for older browsers / restricted environments
                    const el = document.createElement('textarea');
                    el.value = shareableLink;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);
                    showMessage("Shareable link copied to clipboard (fallback)!", 2000);
                });
            } else {
                showMessage("Not in a jam session to share a link.", 3000);
            }
        });

        copyJamIdButton.addEventListener('click', () => {
            if (currentJamId) {
                navigator.clipboard.writeText(currentJamId).then(() => {
                    showMessage("Jam ID copied to clipboard!", 2000);
                }).catch(err => {
                    console.error('Failed to copy text using navigator.clipboard:', err);
                    const el = document.createElement('textarea');
                    el.value = currentJamId;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);
                    showMessage("Jam ID copied to clipboard (fallback)!", 2000);
                });
            } else {
                showMessage("Not in a jam session to copy ID.", 3000);
            }
        });

        leaveJamButton.addEventListener('click', () => {
            if (currentJamId && socket) {
                showConfirmation(
                    "Leave Jam Session?",
                    "Are you sure you want to leave this jam session? If you are the host, the session will end for everyone.",
                    async (confirmed) => {
                        if (confirmed) {
                            try {
                                const jamRef = doc(db, 'jam_sessions', currentJamId);
                                const jamDoc = await getDoc(jamRef);
                                if (jamDoc.exists) {
                                    const jamData = jamDoc.data();
                                    if (jamData.host_sid === socket.id) { // This is the host
                                        await updateDoc(jamRef, {
                                            is_active: false,
                                            ended_at: new Date()
                                        });
                                        showMessage("You have ended the Jam Session for everyone.", 3000);
                                    } else { // This is a participant
                                        const updatedParticipants = jamData.participants || {};
                                        delete updatedParticipants[socket.id]; // Remove self from participants map
                                        await updateDoc(jamRef, {
                                            participants: updatedParticipants
                                        });
                                        showMessage("You have left the Jam Session.", 3000);
                                    }
                                }
                            } catch (e) {
                                console.error("Error leaving jam session:", e);
                                showMessage("Error leaving jam session. Please try again.", 3000);
                            } finally {
                                // Reset client-side state
                                currentJamId = null;
                                isHost = false;
                                myNickname = '';
                                jamSessionPlaylist = [];
                                jamSessionParticipants = {}; // Reset to empty object
                                myPermissions = { play: false, add: false, remove: false };
                                hideJamSessionUI();
                                resetPlayerUI();
                                renderPlaylist(); // Show local playlist (which will be empty)
                                clearInterval(syncInterval); // Stop any host sync interval
                                if (unsubscribeJamListener) {
                                    unsubscribeJamListener(); // Unsubscribe from Firestore
                                    unsubscribeJamListener = null;
                                }
                                // Force a socket disconnect to clean up server-side if not already handled
                                if (socket.connected) {
                                    socket.disconnect();
                                    setupSocketIO(); // Reinitialize socket for fresh connection
                                }
                            }
                        }
                    }
                );
            } else {
                showMessage("You are not currently in a jam session.", 3000);
            }
        });


        // Existing Manage Playlist button listeners
        managePlaylistButton.addEventListener('click', openManagePlaylistModal);

        // --- Add Song Functionality ---
        async function getYouTubeVideoDetails(videoId) {
            try {
                showLoading();
                const response = await fetch(`${FLASK_BACKEND_URL}/youtube_info?url=https://www.youtube.com/watch?v=${videoId}`);
                const data = await response.json();
                hideLoading();
                if (response.ok && data) {
                    return {
                        id: data.video_id, // Ensure consistent ID
                        title: data.title,
                        artist: data.uploader,
                        thumbnail: data.thumbnail || `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
                        type: "youtube",
                        videoId: data.video_id,
                        duration: data.duration
                    };
                } else {
                    showMessage(`Could not find video details for ID: ${videoId}`, 4000);
                    return null;
                }
            } catch (error) {
                hideLoading();
                console.error("Error fetching YouTube video details:", error);
                showMessage(`Error fetching YouTube video details: ${error.message}`, 5000);
                return null;
            }
        }

        async function searchYouTubeVideos(query) {
            try {
                showLoading();
                const response = await fetch(`${FLASK_BACKEND_URL}/Youtube?query=${encodeURIComponent(query)}`);
                const data = await response.json();
                hideLoading();
                if (response.ok && data.length > 0) {
                    return data.map(item => ({
                        id: item.id, // YouTube video ID is the unique ID
                        type: "youtube", 
                        title: item.title,
                        artist: item.uploader,
                        videoId: item.id,
                        thumbnail: item.thumbnail || `https://img.youtube.com/vi/${item.id}/hqdefault.jpg`,
                        duration: item.duration
                    }));
                } else {
                    showMessage("No YouTube videos found for your search query.", 3000);
                    return [];
                }
            } catch (error) {
                hideLoading();
                console.error("Error searching YouTube videos:", error);
                showMessage(`Error searching YouTube: ${error.message}`, 5000);
                return [];
            }
        }
        
        // This function is still needed for hosted MP3 search results
        // I will keep it for now as it's present in the provided HTML.
        function renderGoogleDriveSearchResults(results, targetContainer, directAddToPlaylist) {
            targetContainer.innerHTML = '';
            if (results.length === 0) {
                targetContainer.innerHTML = '<p class="text-center text-gray-500 py-4">No songs found in this folder matching your query.</p>';
                return;
            }
            results.forEach(song => {
                const resultItem = document.createElement('div');
                resultItem.classList.add('flex', 'items-center', 'space-x-3', 'p-2', 'bg-gray-50', 'rounded-lg', 'shadow-sm');
                const thumb = document.createElement('img');
                thumb.src = song.thumbnail || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=MP3';
                thumb.alt = 'Song thumbnail';
                thumb.classList.add('w-10', 'h-10', 'rounded-md', 'object-cover', 'flex-shrink-0');
                const textContent = document.createElement('div');
                textContent.classList.add('flex-grow', 'truncate');
                textContent.innerHTML = `<span class="font-medium block truncate">${song.title}</span><span class="text-xs text-gray-500 block truncate">${song.artist}</span>`;
                const addButton = document.createElement('button');
                addButton.classList.add('ml-2', 'px-3', 'py-1', 'bg-green-500', 'text-white', 'rounded-md', 'hover:bg-green-600', 'transition-colors', 'duration-200', 'flex-shrink-0');
                addButton.innerHTML = '<i class="fas fa-plus mr-1"></i>Add';
                addButton.addEventListener('click', () => {
                    if (isPlayingRandomHostedMode && directAddToPlaylist) {
                        isPlayingRandomHostedMode = false;
                        showMessage("Random play mode disabled. Adding song to playlist.", 3000);
                    }
                    addSongToCurrentPlaylist(song);
                });
                resultItem.appendChild(thumb);
                resultItem.appendChild(textContent);
                resultItem.appendChild(addButton);
                targetContainer.appendChild(resultItem);
            });
        }


        // --- Random Playback ---
        async function fetchAllHostedSongsForRandomPlayback() {
            try {
                showLoading();
                const response = await fetch(`${FLASK_BACKEND_URL}/hosted_songs_manifest.json`);
                const data = await response.json();
                hideLoading();

                if (response.ok && data.length > 0) {
                    fullHostedSongsList = data;
                    showMessage(`Prepared ${fullHostedSongsList.length} songs for random playback.`, 3000);
                } else if (response.ok && data.length === 0) {
                    showMessage("No hosted MP3s found for random playback.", 5000);
                    fullHostedSongsList = [];
                } else {
                    showMessage(`Error preparing random hosted songs: ${data.error || 'Unknown error'}`, 5000);
                    fullHostedSongsList = [];
                }
            } catch (error) {
                hideLoading();
                console.error("Network error fetching full hosted songs list:", error);
                showMessage(`Network error: ${error.message}. Cannot prepare random songs.`, 6000);
                fullHostedSongsList = [];
            }
        }

        async function startDynamicRandomPlayback() {
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to initiate random playback in a Jam Session.", 3000);
                return;
            }
            isPlayingRandomHostedMode = true;
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            activePlaylist.length = 0; // Clear existing playlist

            if (fullHostedSongsList.length === 0) {
                await fetchAllHostedSongsForRandomPlayback();
            }

            if (fullHostedSongsList.length === 0) {
                showMessage("No songs available to start random playback.", 5000);
                resetPlayerUI();
                return;
            }

            // Populate initial queue
            for (let i = 0; i < INITIAL_RANDOM_QUEUE_SIZE; i++) {
                const newSong = getUniqueRandomHostedSong();
                if (newSong) {
                    activePlaylist.push(newSong);
                } else {
                    break;
                }
            }
            shuffleArray(activePlaylist); // Shuffle the initial batch

            if (currentJamId && isHost) {
                // If host, update Firestore playlist and sync state
                try {
                    await updateDoc(doc(db, 'jam_sessions', currentJamId), {
                        playlist: activePlaylist,
                        'playback_state.current_track_index': 0, // Always play the first song in random queue
                        'playback_state.current_playback_time': 0,
                        'playback_state.is_playing': true,
                        'playback_state.timestamp': Date.now() / 1000
                    });
                } catch (e) {
                    console.error("Error starting random playback in Firestore:", e);
                    showMessage("Error starting random playback in jam session. Please try again.", 3000);
                }
            }

            renderPlaylist();
            if (activePlaylist.length > 0) {
                currentTrackIndex = 0;
                loadTrack(currentTrackIndex, true);
                showMessage(`Starting random play with ${activePlaylist.length} songs!`, 3000);
            } else {
                showMessage("Could not populate initial random queue.", 3000);
                resetPlayerUI();
            }
        }
        
        function getUniqueRandomHostedSong() {
            if (fullHostedSongsList.length === 0) {
                return null;
            }
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const availableSongs = fullHostedSongsList.filter(
                (song) => !activePlaylist.some((qSong) => qSong.id === song.id)
            );

            if (availableSongs.length === 0) {
                console.warn("All unique random songs are currently in the queue. Re-using songs.");
                return fullHostedSongsList[Math.floor(Math.random() * fullHostedSongsList.length)]; // Pick any if no unique left
            }
            return availableSongs[Math.floor(Math.random() * availableSongs.length)];
        }


        // --- Jam Session UI & Logic ---
        function enableHostControls(enable) {
            // Playback controls
            const playbackControls = [playPauseButton, prevBtn, nextBtn, progressBar, youtubePlayPauseBtn, youtubePrevBtn, youtubeNextBtn, youtubeProgressBar];
            playbackControls.forEach(btn => {
                if (btn) {
                    btn.disabled = !(enable || myPermissions.play);
                    if (btn.disabled) btn.classList.add('opacity-70', 'cursor-not-allowed');
                    else btn.classList.remove('opacity-70', 'cursor-not-allowed');
                }
            });
            // Volume slider is always enabled (local control)
            volumeSlider.disabled = false;
            volumeSlider.classList.remove('opacity-70', 'cursor-not-allowed');
            youtubeVolumeSlider.disabled = false;
            youtubeVolumeSlider.classList.remove('opacity-70', 'cursor-not-allowed');


            // Add Songs Button & Search Modal Trigger
            searchButton.disabled = !(enable || myPermissions.add);
            if (searchButton.disabled) searchButton.classList.add('opacity-70', 'cursor-not-allowed');
            else searchButton.classList.remove('opacity-70', 'cursor-not-allowed');

            // Random Hosted Songs button
            playRandomHostedSongsButton.disabled = !(enable || myPermissions.add); // Assuming adding songs to playlist is required for random
            if (playRandomHostedSongsButton.disabled) playRandomHostedSongsButton.classList.add('opacity-70', 'cursor-not-allowed');
            else playRandomHostedSongsButton.classList.remove('opacity-70', 'cursor-not-allowed');
            
            // Manage Playlist button
            managePlaylistButton.disabled = !(enable || myPermissions.remove); // Assuming manage implies remove/add
            if (managePlaylistButton.disabled) managePlaylistButton.classList.add('opacity-70', 'cursor-not-allowed');
            else managePlaylistButton.classList.remove('opacity-70', 'cursor-not-allowed');

            // Specific controls within YouTube modal related to adding (if they exist)
            // Assuming addFromUrlButton and performYoutubeTextSearchButton are for adding songs
            if (addFromUrlButton) {
                addFromUrlButton.disabled = !(enable || myPermissions.add);
                if (addFromUrlButton.disabled) addFromUrlButton.classList.add('opacity-70', 'cursor-not-allowed');
                else addFromUrlButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
            if (performYoutubeTextSearchButton) {
                performYoutubeTextSearchButton.disabled = !(enable || myPermissions.add);
                if (performYoutubeTextSearchButton.disabled) performYoutubeTextSearchButton.classList.add('opacity-70', 'cursor-not-allowed');
                else performYoutubeTextSearchButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
            if (youtubeUrlInputModal) youtubeUrlInputModal.disabled = !(enable || myPermissions.add);
            if (youtubeTextSearchInput) youtubeTextSearchInput.disabled = !(enable || myPermissions.add);
            if (searchInput) searchInput.disabled = !(enable || myPermissions.add);


            // Playlist items' clickability (for playing)
            playlistContainer.querySelectorAll('li').forEach(li => {
                const removeButton = li.querySelector('.remove-song-btn');
                if (enable || myPermissions.play) {
                    li.classList.remove('opacity-70', 'cursor-not-allowed');
                } else {
                    li.classList.add('opacity-70', 'cursor-not-allowed');
                }
                // Handle remove button visibility/disability within playlist items
                if (removeButton) {
                    if (enable || myPermissions.remove) {
                        removeButton.classList.remove('opacity-70', 'cursor-not-allowed');
                        removeButton.disabled = false;
                    } else {
                        removeButton.classList.add('opacity-70', 'cursor-not-allowed');
                        removeButton.disabled = true;
                    }
                }
            });
        }

        function showJamSessionUI(jamName, participants) {
            jamControlsDiv.classList.remove('hidden');
            jamNameDisplay.textContent = jamName;
            jamIdDisplay.textContent = `Jam ID: ${currentJamId}`; // Display current jam ID
            participantsCount.textContent = `Participants (${participants.length}):`;

            participantsList.innerHTML = '';
            permissionsList.innerHTML = ''; // Clear permissions list each time

            const participantEntries = Object.entries(participants); // Get [sid, {data}] pairs

            participantEntries.forEach(([sid, data]) => {
                const isMe = (sid === socket.id);
                const isCurrentHost = (sid === jamSessionParticipants[socket.id]?.host_sid); // This might be wrong logic, host_sid is stored at jam level.
                // Re-evaluate: isHost is a global state. Check if `sid` matches `currentJamHostSid`.
                const participantIsHost = (sid === currentJamHostSid);

                const nickname = data.nickname || 'Unknown';
                const permissions = data.permissions || { play: false, add: false, remove: false };

                // Display participant in general list
                const participantLi = document.createElement('li');
                participantLi.className = 'py-1 text-gray-700 dark:text-gray-300';
                participantLi.textContent = `${nickname} ${isMe ? '(You)' : ''} ${participantIsHost ? '(Host)' : ''}`;
                participantsList.appendChild(participantLi);

                // If current client is the host, render permission controls for others
                if (isHost && !isMe) { // Host can manage others' permissions
                    const permissionItem = document.createElement('div');
                    permissionItem.className = 'flex items-center space-x-2 bg-gray-100 p-2 rounded-md mb-1';
                    permissionItem.innerHTML = `
                        <span class="font-medium text-gray-800 flex-shrink-0 w-24 truncate">${nickname}</span>
                        <label class="inline-flex items-center">
                            <input type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" data-permission="play" data-sid="${sid}" ${permissions.play ? 'checked' : ''}>
                            <span class="ml-1 text-sm text-gray-700">Play</span>
                        </label>
                        <label class="inline-flex items-center ml-2">
                            <input type="checkbox" class="form-checkbox h-4 w-4 text-green-600" data-permission="add" data-sid="${sid}" ${permissions.add ? 'checked' : ''}>
                            <span class="ml-1 text-sm text-gray-700">Add</span>
                        </label>
                        <label class="inline-flex items-center ml-2">
                            <input type="checkbox" class="form-checkbox h-4 w-4 text-red-600" data-permission="remove" data-sid="${sid}" ${permissions.remove ? 'checked' : ''}>
                            <span class="ml-1 text-sm text-gray-700">Remove</span>
                        </label>
                    `;
                    permissionsList.appendChild(permissionItem);

                    // Add event listeners for permission checkboxes
                    permissionItem.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        checkbox.addEventListener('change', (event) => {
                            const targetSid = event.target.dataset.sid;
                            const permissionType = event.target.dataset.permission;
                            const isChecked = event.target.checked;
                            const updatedPerms = { [permissionType]: isChecked };
                            socket.emit('update_participant_permissions', {
                                jam_id: currentJamId,
                                target_sid: targetSid,
                                permissions: updatedPerms
                            });
                        });
                    });
                }
            });

            // Show/hide permissions management section based on host status
            if (isHost) {
                permissionsManagementDiv.classList.remove('hidden');
            } else {
                permissionsManagementDiv.classList.add('hidden');
            }
        }

        function hideJamSessionUI() {
            jamControlsDiv.classList.add('hidden');
            jamNameDisplay.textContent = '';
            jamIdDisplay.textContent = 'Jam ID: Loading...';
            participantsCount.textContent = 'Participants (0):';
            participantsList.innerHTML = '';
            permissionsManagementDiv.classList.add('hidden');
            permissionsList.innerHTML = '';
            enableHostControls(true); // Re-enable controls for local playback outside a jam
        }

        // --- Firestore Real-time Synchronization ---
        function subscribeToJamSessionUpdates(jamId) {
            if (unsubscribeJamListener) {
                unsubscribeJamListener(); // Unsubscribe from previous listener if any
            }
            if (!db) {
                console.error("Firestore DB not initialized. Cannot subscribe to updates.");
                return;
            }

            const jamRef = doc(db, 'jam_sessions', jamId);
            unsubscribeJamListener = onSnapshot(jamRef, (docSnapshot) => {
                if (docSnapshot.exists && docSnapshot.data().is_active) {
                    const jamData = docSnapshot.data();
                    console.log("Firestore Jam Data Update:", jamData);

                    // Update client's role and nickname in case they reconnected or host changed
                    isHost = (jamData.host_sid === socket.id);
                    currentJamHostSid = jamData.host_sid;
                    
                    // Update participants and current client's permissions
                    jamSessionParticipants = jamData.participants || {};
                    myPermissions = jamSessionParticipants[socket.id]?.permissions || { play: false, add: false, remove: false };

                    // Update UI for jam session info
                    showJamSessionUI(jamData.name || `Session ${jamId}`, Object.values(jamSessionParticipants).map(p => p.nickname)); // Pass array of nicknames
                    
                    // Render playlist (host or guest)
                    jamSessionPlaylist = jamData.playlist || [];
                    renderPlaylist();
                    updatePlayerControlPermissions(); // Re-apply permissions after UI updates

                    const playbackState = jamData.playback_state || {};
                    const newTrackIndex = playbackState.current_track_index || 0;
                    const newPlaybackTime = playbackState.current_playback_time || 0;
                    const newIsPlaying = playbackState.is_playing || false;
                    const lastSyncedAt = playbackState.timestamp || 0;

                    // Apply playback state if not host, or if host just initialized/reconnected
                    if (!isHost) {
                        // Load track if it's different or if player is empty
                        const currentTrack = jamSessionPlaylist[newTrackIndex];
                        const needsTrackLoad = (newTrackIndex !== currentTrackIndex || 
                                                (currentTrack && currentTrack.type === 'youtube' && youtubePlayer && youtubePlayer.getVideoData().video_id !== currentTrack.videoId) ||
                                                (currentTrack && currentTrack.type === 'audio' && audioPlayer.src !== currentTrack.url));

                        if (needsTrackLoad) {
                            currentTrackIndex = newTrackIndex;
                            loadTrack(currentTrackIndex, newIsPlaying);
                        }

                        // Latency correction
                        const networkDelay = (Date.now() / 1000) - lastSyncedAt;
                        let targetTime = newPlaybackTime + networkDelay + 0.1; // Small buffer

                        if (currentTrack) {
                            let player;
                            let duration;
                            if (currentTrack.type === 'audio') {
                                player = audioPlayer;
                                duration = audioPlayer.duration;
                            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                player = youtubePlayer;
                                duration = youtubePlayer.getDuration();
                            }
                            
                            if (player && !isNaN(duration) && isFinite(duration) && duration > 0) {
                                targetTime = Math.min(Math.max(0, targetTime), duration);

                                let currentTime = 0;
                                if (currentTrack.type === 'audio') {
                                    currentTime = audioPlayer.currentTime;
                                } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                    currentTime = youtubePlayer.getCurrentTime();
                                }
                                const timeDifference = Math.abs(currentTime - targetTime);

                                if (timeDifference > 1.0) { // Seek if more than 1 second out of sync
                                    console.log(`Follower Seeking: current ${currentTime.toFixed(2)}, target ${targetTime.toFixed(2)}, diff ${timeDifference.toFixed(2)}, delay ${networkDelay.toFixed(2)}`);
                                    if (currentTrack.type === 'audio') {
                                        player.currentTime = targetTime;
                                    } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                        player.seekTo(targetTime, true);
                                    }
                                }

                                // Play/pause state sync
                                if (newIsPlaying && (player.paused || (currentTrack.type === 'youtube' && player.getPlayerState() !== YT.PlayerState.PLAYING))) {
                                    if (currentTrack.type === 'audio') {
                                        player.play().catch(e => console.error("Error playing audio (guest):", e));
                                    } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                        youtubePlayer.playVideo();
                                    }
                                } else if (!newIsPlaying && (!player.paused || (currentTrack.type === 'youtube' && player.getPlayerState() === YT.PlayerState.PLAYING))) {
                                    if (currentTrack.type === 'audio') {
                                        player.pause();
                                    } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                        youtubePlayer.pauseVideo();
                                    }
                                }
                            } else {
                                console.warn("Guest: Player or duration not ready for sync.");
                            }
                        }
                        // Permissions for guests are set by host, enableHostControls will disable controls if not host
                        enableHostControls(false); 
                        showMessage("Syncing with Jam Session!", 1000);
                    } else { // If host, just ensure UI reflects latest state and controls are enabled
                        enableHostControls(true);
                    }

                } else {
                    // Session ended or document no longer exists in Firestore
                    showMessage(`Jam Session "${jamId}" has ended.`, 5000);
                    currentJamId = null;
                    isHost = false;
                    myNickname = '';
                    jamSessionPlaylist = [];
                    jamSessionParticipants = {}; // Reset to empty object
                    myPermissions = { play: false, add: false, remove: false };
                    hideJamSessionUI();
                    resetPlayerUI();
                    renderPlaylist(); // Show local playlist
                    clearInterval(syncInterval); // Stop any host sync interval
                    if (unsubscribeJamListener) unsubscribeJamListener();
                    // Force a socket disconnect to clean up server-side if not already handled
                    if (socket.connected) {
                        socket.disconnect();
                        setupSocketIO(); // Reinitialize socket for fresh connection
                    }
                }
            }, (error) => {
                console.error("Error listening to jam session updates:", error);
                showMessage("Lost connection to Jam Session. Please try rejoining.", 5000);
                currentJamId = null;
                isHost = false;
                myNickname = '';
                jamSessionPlaylist = [];
                jamSessionParticipants = {};
                myPermissions = { play: false, add: false, remove: false };
                hideJamSessionUI();
                resetPlayerUI();
                renderPlaylist();
                clearInterval(syncInterval);
                if (unsubscribeJamListener) unsubscribeJamListener();
                if (socket.connected) {
                    socket.disconnect();
                    setupSocketIO(); // Reinitialize socket for fresh connection
                }
            });
        }

        // Host-only function to update Firestore with current playback state
        async function updateFirestorePlaybackState(isPlayingOverride = null, trackIndexOverride = null, playbackTimeOverride = null) {
            if (!currentJamId || !isHost || !db) return;

            const currentTrack = jamSessionPlaylist[currentTrackIndex]; // Host manages its local playlist (jamSessionPlaylist)
            if (!currentTrack) return;

            let currentTime = playbackTimeOverride !== null ? playbackTimeOverride : 0;
            let isPlaying = isPlayingOverride !== null ? isPlayingOverride : false;
            let trackIndex = trackIndexOverride !== null ? trackIndexOverride : currentTrackIndex;

            if (currentTrack.type === 'audio') {
                currentTime = playbackTimeOverride !== null ? playbackTimeOverride : audioPlayer.currentTime;
                isPlaying = isPlayingOverride !== null ? isPlayingOverride : !audioPlayer.paused;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                currentTime = playbackTimeOverride !== null ? playbackTimeOverride : youtubePlayer.getCurrentTime();
                isPlaying = isPlayingOverride !== null ? isPlayingOverride : (youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING);
            }

            try {
                await updateDoc(doc(db, 'jam_sessions', currentJamId), {
                    'playback_state.current_track_index': trackIndex,
                    'playback_state.current_playback_time': currentTime,
                    'playback_state.is_playing': isPlaying,
                    'playback_state.timestamp': Date.now() / 1000 // Client timestamp for latency calculation
                });
                // No explicit socket emit from host here, as Firestore listener handles propagation
            } catch (e) {
                console.error("Error updating Firestore playback state:", e);
                showMessage("Failed to sync playback state to jam. Check connection.", 3000);
            }
        }


        // --- Event Listeners ---

        // Handle Create Jam Session button within the modal
        createJamButton.addEventListener('click', async () => {
            if (!userId) {
                showMessage("Authentication not ready. Please wait or refresh.", 3000);
                return;
            }
            const jamName = createJamNameInput.value.trim();
            const nickname = createJamNicknameInput.value.trim();
            if (!nickname) {
                showMessage("Please enter your nickname to create a session.", 3000);
                return;
            }
            myNickname = nickname;
            
            // Emit to backend, backend saves to Firestore and returns jam_id
            socket.emit('create_session', { jam_name: jamName, nickname: nickname });
            // The 'session_created' event will be received from the backend, which will then trigger Firestore listener
        });

        // Handle Copy Share Link button
        copyShareLinkButton.addEventListener('click', () => {
            const link = jamShareLinkInput.value;
            if (link) {
                // Using modern clipboard API with fallback
                navigator.clipboard.writeText(link).then(() => {
                    showMessage("Link copied to clipboard!", 2000);
                }).catch(err => {
                    console.error('Failed to copy text using navigator.clipboard:', err);
                    // Fallback for older browsers / restricted environments
                    const el = document.createElement('textarea');
                    el.value = link;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);
                    showMessage("Link copied to clipboard (fallback)!", 2000);
                });
            }
        });

        // Handle Join Jam Session button within the modal
        joinJamButton.addEventListener('click', async () => {
            if (!userId) {
                showMessage("Authentication not ready. Please wait or refresh.", 3000);
                return;
            }
            const nickname = joinJamNicknameInput.value.trim();
            const enteredJamId = joinJamIdInput.value.trim(); // Ensure this is populated from the input
            if (!nickname) {
                showMessage("Please enter your nickname to join the session.", 3000);
                return;
            }
            if (!enteredJamId) {
                showMessage("Please enter a Jam ID.", 3000);
                return;
            }

            myNickname = nickname;
            currentJamId = enteredJamId; // Set the jamId to be joined

            // Emit to backend, backend joins in Firestore
            socket.emit('join_session', { jam_id: currentJamId, nickname: nickname });
            joinJamModal.classList.add('hidden');
            // Firestore listener will update the state
        });

        // Existing Manage Playlist button listeners
        managePlaylistButton.addEventListener('click', openManagePlaylistModal);

        // Event listeners for elements now in their respective modals
        // (Google Drive Search is now part of the main search modal, not separate)
        // This button and its corresponding input/results container are removed from the current HTML.
        // I'll keep the function definition in case it's used elsewhere, but remove the event listener.
        // performGoogledriveMainSearchButton.addEventListener('click', async () => {
        //     const query = googledriveMainSearchInput.value.trim();
        //     if (isPlayingRandomHostedMode) { // Changed from Drive to Hosted
        //         isPlayingRandomHostedMode = false;
        //         showMessage("Random play mode disabled. Adding search results to playlist.", 3000);
        //     }
        //     await searchSongsInGoogleDriveFolder(PUBLIC_TELUGU_SONGS_FOLDER_ID, query, googledriveMainSearchResults, true);
        // });

        addFromUrlButton.addEventListener('click', async () => {
            const url = youtubeUrlInputModal.value.trim();
            if (!url) { showMessage("Please enter a YouTube URL.", 2000); return; }

            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to add songs to this jam.", 3000);
                return;
            }

            const videoId = extractYouTubeVideoId(url);
            if (!videoId) { showMessage("Invalid YouTube URL.", 2000); return; }
            const track = await getYouTubeVideoDetails(videoId);
            if (track) {
                addSongToCurrentPlaylist(track);
                closeYoutubeModal();
            }
        });

        performYoutubeTextSearchButton.addEventListener('click', async () => {
            const query = youtubeTextSearchInput.value.trim();
            if (!query) { showMessage("Please enter a search query.", 2000); return; }

            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to add songs to this jam.", 3000);
                return;
            }

            const results = await searchYouTubeVideos(query);
            renderYouTubeSearchResults(results);
        });

        playRandomHostedSongsButton.addEventListener('click', async () => { // Renamed from Drive to Hosted
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to initiate random playback in a Jam Session.", 3000);
                return;
            }
            // Removed the Google Drive folder ID check here, as it's now about hosted_songs_manifest.json
            await startDynamicRandomPlayback();
        });


        // Function to handle initial load and jam join
        async function handleInitialLoadAndJamJoin() {
            renderPlaylist(); // Render initial empty playlist or saved local one
            loadYouTubeAPI(); // Load YouTube IFrame API

            volumeSlider.value = audioPlayer.volume * 100; // Initialize volume slider from current player volume
            // Ensure volume slider's visual fill is set
            volumeSlider.style.setProperty('--volume', `${volumeSlider.value}%`);
            youtubeVolumeSlider.value = audioPlayer.volume * 100;
            youtubeVolumeSlider.style.setProperty('--volume', `${youtubeVolumeSlider.value}%`);


            // Hide all modals and dropdowns initially
            searchModal.classList.add('hidden'); // Main search modal
            addSongModal.classList.add('hidden'); // Add song confirmation modal
            youtubeModal.classList.add('hidden');
            managePlaylistModal.classList.add('hidden');
            createJamModal.classList.add('hidden');
            joinJamModal.classList.add('hidden');
            jamControlsDiv.classList.add('hidden'); // Hide jam controls initially
            permissionsManagementDiv.classList.add('hidden'); // Hide permissions management initially


            // Check URL for jam_id on page load
            const urlParams = new URLSearchParams(window.location.search);
            const urlJamId = urlParams.get('jam_id') || (window.location.pathname.startsWith('/join/') ? window.location.pathname.substring(6) : null);
            
            if (urlJamId) {
                joinJamIdInput.value = urlJamId; // Pre-fill the input
                // Fetch jam name for display before joining
                if (db) {
                    try {
                        const jamDoc = await getDoc(doc(db, 'jam_sessions', urlJamId));
                        if (jamDoc.exists && jamDoc.data().is_active) {
                            joinJamNameDisplay.textContent = `Joining: ${jamDoc.data().name || `Session ${urlJamId}`}`;
                        } else {
                            joinJamNameDisplay.textContent = `Session ${urlJamId} (Not Found or Inactive)`;
                            showMessage(`Jam session ${urlJamId} not found or is inactive.`, 5000);
                        }
                    } catch (e) {
                        console.error("Error fetching jam name for join modal:", e);
                        joinJamNameDisplay.textContent = `Session ${urlJamId} (Error Loading)`;
                        showMessage("Error retrieving jam details.", 5000);
                    }
                }
                joinJamModal.classList.remove('hidden'); // Show the modal for user to enter nickname and join
            } else {
                showMessage("Welcome! Use 'Search & Add Songs' or 'Play Random Hosted MP3s'.", 3000);
                songTitleSpan.textContent = "No song loaded";
                songArtistSpan.textContent = "";
                songThumbnailImg.src = "https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Track";
            }
        }
        
        // This function will be called on 'DOMContentLoaded'
        document.addEventListener('DOMContentLoaded', handleInitialLoadAndJamJoin);

        // This is a placeholder for the `confirm` function to be replaced by `showConfirmation`
        window.confirm = (message) => {
            console.warn("Using deprecated window.confirm(). Please refactor to showConfirmation.");
            // Default to true for backward compatibility if not replaced.
            return true;
        };

    </script>
</body>
</html>
