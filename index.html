<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TuneJam - Collaborative Audio Player</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Socket.IO Client Library -->
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <!-- YouTube IFrame Player API -->
    <script src="https://www.youtube.com/iframe_api"></script> 
    <!-- Firebase SDK (New) -->
    <script type="module">
        // Import the functions you need from the SDKs you need
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, arrayUnion, arrayRemove, deleteDoc, collection, query, where, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your Firebase project configuration (REPLACE WITH YOUR ACTUAL CONFIG)
        const firebaseConfig = {
            apiKey: "YOUR_FIREBASE_API_KEY", // Replace with your actual Firebase API Key
            authDomain: "YOUR_FIREBASE_AUTH_DOMAIN", // Replace with your actual Firebase Auth Domain
            projectId: "YOUR_FIREBASE_PROJECT_ID", // Replace with your actual Firebase Project ID
            storageBucket: "YOUR_FIREBASE_STORAGE_BUCKET", // Replace with your actual Firebase Storage Bucket
            messagingSenderId: "YOUR_FIREBASE_MESSAGING_SENDER_ID", // Replace with your actual Firebase Messaging Sender ID
            appId: "YOUR_FIREBASE_APP_ID", // Replace with your actual Firebase App ID
            measurementId: "YOUR_FIREBASE_MEASUREMENT_ID" // Replace with your actual Firebase Measurement ID
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        // Make Firebase instances globally accessible for the script section
        // This is necessary because type="module" scripts create a private scope.
        // By attaching to window, these instances can be accessed by the second script block.
        window.firebaseApp = app;
        window.firebaseDb = db;
        window.firebaseAuth = auth;
        window.firebaseDoc = doc; // Expose doc for easier use
        window.firebaseOnSnapshot = onSnapshot; // Expose onSnapshot
        window.firebaseGetDoc = getDoc; // Expose getDoc
        window.firebaseSetDoc = setDoc; // Expose setDoc
        window.firebaseUpdateDoc = updateDoc; // Expose updateDoc
        window.firebaseDeleteDoc = deleteDoc; // Expose deleteDoc
        window.firebaseCollection = collection; // Expose collection
        window.firebaseSignInAnonymously = signInAnonymously; // Expose signInAnonymously
        window.firebaseOnAuthStateChanged = onAuthStateChanged; // Expose onAuthStateChanged
        window.firebaseSignInWithCustomToken = signInWithCustomToken; // Expose signInWithCustomToken (FIXED TYPO)
    </script>
    
    <style>
        /* Custom styles to enhance Tailwind's default behavior and provide specific overrides */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            gap: 20px; /* Space between player and playlist */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        @media (max-width: 768px) {
            body {
                flex-direction: column;
                padding: 10px;
            }
            .audio-player-card, .playlist-card { /* Changed to match HTML class names */
                width: 100%;
                max-width: none;
            }
        }
        /* Hide default audio controls */
        audio {
            display: none;
        }

        /* Custom range input styling for progress and volume bars */
        input[type="range"] {
            -webkit-appearance: none; /* Override default appearance */
            appearance: none;
            width: 100%;
            height: 8px;
            background: #d1d5db; /* Light grey track */
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
            border-radius: 5px; /* Rounded track */
        }

        input[type="range"]:hover {
            opacity: 1;
        }

        /* Thumb styling for WebKit (Chrome, Safari) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #4F46E5; /* Indigo thumb */
            cursor: pointer;
            border-radius: 50%; /* Circular thumb */
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
            margin-top: -6px; /* Center thumb vertically */
        }

        /* Thumb styling for Firefox */
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #4F46E5;
            cursor: pointer;
            border-radius: 50%;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* Custom track styling for Firefox */
        input[type="range"]::-moz-range-track {
            background: #d1d5db;
            border-radius: 5px;
        }

        /* Styling for filled portion of the range input */
        .progress-bar-container input[type="range"] {
            background: linear-gradient(to right, #4F46E5 var(--progress, 0%), #d1d5db var(--progress, 0%));
        }
        .volume-bar-container input[type="range"] {
            background: linear-gradient(to right, #4F46E5 var(--volume, 100%), #d1d5db var(--volume, 100%));
        }

        /* Play/Pause button 'is-playing' animation */
        .play-pause-button.is-playing {
            animation: pulse-scale 1.5s infinite ease-in-out;
        }

        @keyframes pulse-scale {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 rgba(79, 70, 229, 0.7);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 15px rgba(79, 70, 229, 0.7);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 rgba(79, 70, 229, 0);
            }
        }

        /* Utility for icon size */
        .icon-size {
            font-size: 1.25rem; /* Smaller default icon size */
        }

        /* Playlist item active state */
        .playlist-item.current-song {
            background-color: #e0e7ff; /* Light indigo background */
            color: #4F46E5; /* Indigo text */
            font-weight: 600;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        /* Modal specific styles (updated to match HTML with 'modal' class instead of modal-overlay/modal-content structure previously used) */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal-content {
            background-color: #fff;
            padding: 2rem; /* Adjusted for consistency */
            border-radius: 0.75rem; /* Adjusted for consistency */
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            transform: translateY(-50px);
            opacity: 0;
            animation: modal-fade-in 0.3s forwards ease-out; /* Uses the new modal animation */
        }
        /* New modal animation keyframes from previously generated code */
        @keyframes modal-fade-in {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        @keyframes modal-fade-out {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-50px); opacity: 0; }
        }
        .modal.hidden .modal-content {
            animation: modal-fade-out 0.3s forwards ease-in;
        }


        .modal-close-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #6b7280;
            transition: color 0.2s;
        }

        .modal-close-button:hover {
            color: #ef4444; /* Red on hover */
        }

        /* YouTube Iframe styling */
        #youtube-player-iframe {
            width: 100%;
            height: 100%;
            border-radius: 0.75rem; /* Matches album art rounded-xl */
            display: block; /* Ensures it takes up space */
        }

        /* Loading indicator styling */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }

        .spinner {
            border: 6px solid #f3f3f3;
            border-top: 6px solid #4F46E5;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Custom Message Box */
        #custom-message-box {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 0.9rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            z-index: 3000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }
        #custom-message-box.show {
            opacity: 1;
        }

        /* Custom scrollbar for overflow areas */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Responsive adjustments for smaller screens */
        @media (max-width: 768px) {
            body {
                flex-direction: column; /* Stack player and playlist vertically */
                align-items: center;
                gap: 20px;
            }
            .audio-player-card, .playlist-card {
                width: 95%; /* Adjust width for smaller screens */
                max-width: 380px; /* Limit max width */
            }
            .icon-size {
                font-size: 1.1rem; /* Even smaller icon size on small screens */
            }
            .text-xl {
                font-size: 1rem; /* Adjust title size */
            }
            .text-sm {
                font-size: 0.7rem; /* Adjust duration font size */
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 to-purple-100 min-h-screen flex justify-center items-center p-4">

    <!-- Main Player Section -->
    <div class="audio-player-card bg-white shadow-xl rounded-2xl p-6 md:p-8 w-full max-w-sm border border-gray-100">
        <h2 class="text-2xl md:text-3xl font-extrabold text-center text-gray-800 mb-6 tracking-tight">
            Music Player
        </h2>
        
        <div id="album-art-container" class="w-24 h-24 md:w-32 md:h-32 mx-auto mb-6 bg-gray-200 rounded-xl overflow-hidden shadow-md flex items-center justify-center">
            <img id="album-art" src="https://placehold.co/128x128/4F46E5/FFFFFF?text=Album+Art"
                 alt="Album Art" class="w-full h-full object-cover">
            <div id="youtube-player-iframe" class="hidden"></div>
        </div>

        <div class="text-center mb-6">
            <h3 id="track-title" class="text-lg md:text-xl font-bold text-gray-900 truncate">No song loaded</h3>
            <p id="artist-name" class="text-xs md:text-sm text-gray-600 truncate"></p>
        </div>

        <audio id="audio-player"></audio>

        <div class="progress-bar-container w-full mb-4">
            <input type="range" id="progress-bar" value="0" min="0" max="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer bg-gray-200">
            <div class="flex justify-between text-xs text-gray-600 mt-2">
                <span id="current-time">0:00</span>
                <span id="total-time">0:00</span>
            </div>
        </div>

        <div class="flex items-center justify-center space-x-4 mb-6">
            <button id="rewind-button" class="text-gray-700 hover:text-indigo-600 focus:outline-none transition-transform duration-200 ease-in-out active:scale-95">
                <i class="fas fa-backward icon-size"></i>
            </button>

            <button id="play-pause-button" class="w-14 h-14 md:w-16 md:h-16 bg-indigo-600 text-white rounded-full flex items-center justify-center shadow-lg hover:bg-indigo-700 focus:outline-none transition-all duration-300 ease-in-out">
                <i id="play-pause-icon" class="fas fa-play text-xl md:text-2xl"></i>
            </button>

            <button id="forward-button" class="text-gray-700 hover:text-indigo-600 focus:outline-none transition-transform duration-200 ease-in-out active:scale-95">
                <i class="fas fa-forward icon-size"></i>
            </button>

            <button id="next-button" class="text-gray-700 hover:text-indigo-600 focus:outline-none transition-transform duration-200 ease-in-out active:scale-95">
                <i class="fas fa-forward-step icon-size"></i>
            </button>
        </div>

        <div class="volume-bar-container flex items-center space-x-3 w-full">
            <i class="fas fa-volume-down text-gray-600 text-base"></i>
            <input type="range" id="volume-bar" value="100" min="0" max="100" class="flex-grow h-2 rounded-lg appearance-none cursor-pointer bg-gray-200">
            <i class="fas fa-volume-up text-gray-600 text-base"></i>
        </div>
        <div class="flex justify-center mt-6">
            <button id="play-random-netlify-songs-button" class="px-4 py-2 bg-purple-600 text-white rounded-lg shadow hover:bg-purple-700 transition-colors duration-200 text-sm">
                <i class="fas fa-random mr-2"></i>Play Random Netlify Songs
            </button>
        </div>
    </div>

    <div class="playlist-card bg-white shadow-xl rounded-2xl p-6 md:p-8 w-full max-w-sm border border-gray-100">
        <!-- Jam Session Info Display -->
        <div id="jam-session-info" class="text-center mb-4 hidden">
            <p class="text-indigo-600 font-bold text-lg">Jam Session: <span id="jam-name-display"></span></p>
            <p class="text-gray-600 text-sm">Participants: <span id="jam-participants-display"></span></p>
            <button id="leave-jam-session-button" class="mt-2 px-3 py-1 bg-red-500 text-white rounded-md text-xs hover:bg-red-600 transition-colors duration-200">Leave Jam</button>
            
            <!-- Host Permissions Management Section - RE-INTEGRATED -->
            <div id="permissions-management" class="mt-4 hidden text-left p-2 bg-gray-50 rounded-lg">
                <h4 class="text-md font-semibold text-gray-700 mb-2">Manage Participant Permissions:</h4>
                <!-- Basic participants list for all users in a jam -->
                <ul id="participants-list" class="text-sm text-gray-700 max-h-24 overflow-y-auto custom-scrollbar mb-2">
                    <!-- Participants will be listed here, e.g. "Nickname (You)" or "Nickname (Host)" -->
                </ul>
                <div id="permissions-list" class="space-y-2">
                    <!-- Host-only permission controls (checkboxes) will be rendered here for each non-host participant -->
                </div>
            </div>
        </div>

        <div class="flex justify-between items-center mb-6">
            <h2 class="text-2xl md:text-3xl font-extrabold text-gray-800 tracking-tight">
                Playlist
            </h2>
            <div class="relative flex items-center space-x-2">
                <!-- Three dots icon for Jam Session and YouTube options -->
                <button id="open-options-dropdown-button" class="px-3 py-2 bg-gray-600 text-white rounded-lg shadow hover:bg-gray-700 transition-colors duration-200 text-sm">
                    <i class="fas fa-ellipsis-v"></i> <!-- Three dots icon -->
                </button>
                <!-- Options dropdown -->
                <div id="options-dropdown" class="absolute right-0 top-full mt-2 w-48 bg-white rounded-md shadow-lg z-10 hidden">
                    <a href="#" id="add-youtube-song-dropdown" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                        <i class="fab fa-youtube mr-2"></i>Add YouTube Song
                    </a>
                    <a href="#" id="create-jam-session-dropdown-btn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                        <i class="fas fa-headphones mr-2"></i>Create Jam Session
                    </a>
                    <!-- Adding join jam session to dropdown as it was in the original comprehensive design -->
                    <a href="#" id="join-jam-session-dropdown-btn" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100">
                        <i class="fas fa-users mr-2"></i>Join Jam Session
                    </a>
                </div>
            </div>
        </div>

        <!-- Buttons repositioned as per user request -->
        <div class="flex justify-center space-x-4 mb-6 flex-wrap">
            <button id="add-songs-button" class="px-3 py-2 bg-green-600 text-white rounded-lg shadow hover:bg-green-700 transition-colors duration-200 text-sm">
                <i class="fas fa-plus mr-2"></i>Add Songs
            </button>
            <button id="manage-playlist-button" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg shadow hover:bg-gray-300 transition-colors duration-200 text-sm">
                <i class="fas fa-edit mr-2"></i>Manage Playlist
            </button>
        </div>

        <!-- New: Netlify Local MP3 Search Section (moved from modal) -->
        <div id="netlify-search-section" class="w-full hidden mt-4 border-t border-gray-200 pt-6">
            <h4 class="text-xl font-bold text-gray-700 mb-3 text-center">Search Local MP3s</h4>
            <div class="flex space-x-2 mb-3">
                <input type="text" id="netlify-search-input" placeholder="Search song by title or artist"
                       class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500">
                <button id="perform-netlify-search" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors duration-200">
                    <i class="fas fa-search"></i>
                </button>
            </div>
            <div id="netlify-search-results" class="max-h-60 overflow-y-auto space-y-2 mb-4 custom-scrollbar">
                <!-- Search results will be rendered here -->
            </div>
        </div>

        <ul id="playlist-container" class="space-y-3 max-h-80 overflow-y-auto pr-2 mt-6 border-t border-gray-200 pt-6 custom-scrollbar">
        </ul>
    </div>

    <!-- YouTube Modal -->
    <div id="youtube-modal" class="modal hidden">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeYoutubeModal()">×</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Add Songs from YouTube</h3>

            <div class="mb-6 border-b border-gray-200 pb-4">
                <h4 class="text-xl font-bold text-gray-700 mb-3">Add by URL</h4>
                <p class="text-sm text-gray-600 mb-2">
                    Enter a YouTube video URL or playlist URL.
                </p>
                <input type="text" id="youtube-url-input-modal" placeholder="YouTube Video/Playlist URL"
                       class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 mb-3">
                <button id="add-from-url-button" class="w-full bg-red-600 text-white py-2 rounded-md hover:bg-red-700 transition-colors duration-200">
                    <i class="fas fa-link mr-2"></i>Add URL
                </button>
            </div>

            <div>
                <h4 class="text-xl font-bold text-gray-700 mb-3">Search by Name</h4>
                <div class="flex space-x-2 mb-3">
                    <input type="text" id="youtube-text-search-input" placeholder="Search video by name"
                           class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="perform-youtube-text-search" class="px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 transition-colors duration-200">
                        <i class="fas fa-search"></i>
                    </button>
                </div>
                <div id="youtube-search-results" class="max-h-60 overflow-y-auto space-y-2 custom-scrollbar"></div>
            </div>
        </div>
    </div>

    <!-- Manage Playlist Modal (existing) -->
    <div id="manage-playlist-modal" class="modal hidden">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeManagePlaylistModal()">×</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Manage Playlist</h3>
            <ul id="editable-playlist-container" class="space-y-3 max-h-80 overflow-y-auto pr-2 custom-scrollbar">
            </ul>
            <p id="playlist-empty-message" class="text-center text-gray-500 mt-4 hidden">Playlist is empty.</p>
        </div>
    </div>

    <!-- Create Jam Session Modal -->
    <div id="create-jam-modal" class="modal hidden">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeCreateJamModal()">×</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Create New Jam Session</h3>
            <div class="mb-4">
                <label for="jam-name-input" class="block text-sm font-medium text-gray-700 mb-1">Jam Name (optional):</label>
                <input type="text" id="jam-name-input" placeholder="My Awesome Jam"
                       class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
             <div class="mb-4">
                <label for="nickname-input-create" class="block text-sm font-medium text-gray-700 mb-1">Your Nickname:</label>
                <input type="text" id="nickname-input-create" placeholder="Host" value="Host"
                       class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <button id="create-jam-button" class="w-full bg-indigo-600 text-white py-2 rounded-md hover:bg-indigo-700 transition-colors duration-200">
                <i class="fas fa-plus-circle mr-2"></i>Create Session
            </button>
            <div id="share-link-container" class="mt-6 p-3 bg-gray-100 border border-gray-200 rounded-lg hidden">
                <p class="text-sm font-medium text-gray-700 mb-2">Share this link to invite others:</p>
                <div class="flex items-center space-x-2">
                    <input type="text" id="jam-share-link" readonly
                           class="flex-grow px-3 py-2 bg-white border border-gray-300 rounded-md text-sm text-gray-700 truncate">
                    <button id="copy-share-link-button" class="px-3 py-2 bg-green-500 text-white rounded-md hover:bg-green-600 transition-colors duration-200">
                        <i class="fas fa-copy"></i> Copy
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Join Jam Session Modal -->
    <div id="join-jam-modal" class="modal hidden">
        <div class="modal-content">
            <button class="modal-close-button" onclick="closeJoinJamModal()">×</button>
            <h3 class="text-2xl font-bold text-gray-800 mb-6 text-center">Join Jam Session</h3>
            <p id="join-jam-name-display" class="text-lg text-center text-indigo-600 font-semibold mb-4"></p>
            <div class="mb-4">
                <label for="nickname-input-join" class="block text-sm font-medium text-gray-700 mb-1">Your Nickname:</label>
                <input type="text" id="nickname-input-join" placeholder="Anonymous Listener"
                       class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <!-- Jam ID Input field -->
            <div class="mb-4">
                <label for="join-jam-id-input" class="block text-sm font-medium text-gray-700 mb-1">Jam ID:</label>
                <input type="text" id="join-jam-id-input" placeholder="Enter Jam ID"
                       class="block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500">
            </div>
            <button id="join-jam-button" class="w-full bg-blue-600 text-white py-2 rounded-md hover:bg-blue-700 transition-colors duration-200">
                <i class="fas fa-door-open mr-2"></i>Join Session
            </button>
        </div>
    </div>


    <div id="custom-message-box" class="hidden"></div>
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="spinner"></div>
    </div>

    <!-- Confirmation Modal -->
    <div id="confirmation-modal" class="modal hidden">
        <div class="modal-content">
            <h3 id="confirmation-modal-title" class="text-xl font-bold text-gray-800 mb-4 text-center"></h3>
            <p id="confirmation-modal-message" class="text-gray-700 mb-6 text-center"></p>
            <div class="flex justify-center space-x-4">
                <button id="confirm-yes-btn" class="bg-red-500 text-white py-2 px-6 rounded-lg hover:bg-red-600 transition-colors duration-200">Yes</button>
                <button id="confirm-no-btn" class="bg-gray-300 text-gray-800 py-2 px-6 rounded-lg hover:bg-gray-400 transition-colors duration-200">No</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Globally accessible Firebase instances (initialized in the script tag above)
        // These are made available through `window` object by the first script block.
        const db = window.firebaseDb;
        const auth = window.firebaseAuth;
        const doc = window.firebaseDoc;
        const onSnapshot = window.firebaseOnSnapshot;
        const getDoc = window.firebaseGetDoc;
        const setDoc = window.firebaseSetDoc;
        const updateDoc = window.firebaseUpdateDoc;
        const deleteDoc = window.firebaseDeleteDoc;
        const collection = window.firebaseCollection;
        const signInAnonymously = window.firebaseSignInAnonymously;
        const onAuthStateChanged = window.firebaseOnAuthStateChanged;
        const signInWithCustomToken = window.firebaseSignInWithCustomToken;


        const FLASK_BACKEND_URL = ''; // Leave empty if running on the same domain/port, or specify 'http://localhost:5000' if your Flask backend is separate and running locally
        
        // Socket.IO setup (used for direct signaling, complementing Firestore for state)
        const socket = io(FLASK_BACKEND_URL); 
        
        let currentJamId = null;
        let isHost = false;
        let myNickname = '';
        let jamSessionPlaylist = []; // The playlist for the current jam session, synchronized from Firestore
        // Note: jamSessionParticipants should be an object (map) for Firestore, but rendered as an array for display
        let jamSessionParticipants = {}; // {sid: {nickname: '...', permissions: {}}}
        let unsubscribeJamListener = null; // To unsubscribe from Firestore snapshot listener
        let myPermissions = { play: true, add: true, remove: true }; // Default permissions for individual (can be overridden by jam host)

        // Global YouTube Player variable
        let youtubePlayer;
        let youtubePlayerReady = false;

        let isPlayingRandomNetlifyMode = false; // Renamed from isPlayingRandomDriveMode
        let hostedSongsList = []; // Stores the full list of hosted MP3s from manifest for random playback and search
        const RANDOM_QUEUE_SIZE = 5; // Number of random songs to queue initially


        // --- DOM Elements ---
        const audioPlayer = document.getElementById('audio-player');
        const playPauseButton = document.getElementById('play-pause-button');
        const playPauseIcon = document.getElementById('play-pause-icon');
        const progressBar = document.getElementById('progress-bar');
        const currentTimeSpan = document.getElementById('current-time');
        const totalTimeSpan = document.getElementById('total-time');
        const volumeBar = document.getElementById('volume-bar');
        const rewindButton = document.getElementById('rewind-button');
        const forwardButton = document.getElementById('forward-button');
        const nextButton = document.getElementById('next-button');
        const trackTitle = document.getElementById('track-title');
        const artistName = document.getElementById('artist-name');
        const albumArt = document.getElementById('album-art');
        const youtubeIframeDiv = document.getElementById('youtube-player-iframe'); // Matched ID with HTML

        const playlistContainer = document.getElementById('playlist-container');

        // Buttons and Dropdowns (matching selected HTML IDs)
        const addSongsButton = document.getElementById('add-songs-button'); // Main 'Add Songs' button
        const netlifySearchSection = document.getElementById('netlify-search-section'); // NEW: Netlify search section
        const openOptionsDropdownButton = document.getElementById('open-options-dropdown-button'); // Three dots button
        const optionsDropdown = document.getElementById('options-dropdown'); // Dropdown menu
        const addYoutubeSongDropdown = document.getElementById('add-youtube-song-dropdown'); // "Add YouTube Song" option
        const createJamSessionDropdownBtn = document.getElementById('create-jam-session-dropdown-btn'); // "Create Jam Session" option
        const joinJamSessionDropdownBtn = document.getElementById('join-jam-session-dropdown-btn'); // "Join Jam Session" option in dropdown
        const managePlaylistButton = document.getElementById('manage-playlist-button');
        const playRandomNetlifySongsButton = document.getElementById('play-random-netlify-songs-button'); // Renamed ID

        // Modals (matching selected HTML IDs)
        const youtubeModal = document.getElementById('youtube-modal');
        const managePlaylistModal = document.getElementById('manage-playlist-modal');

        // Elements within Netlify Section (NEW)
        const netlifySearchInput = document.getElementById('netlify-search-input');
        const performNetlifySearchButton = document.getElementById('perform-netlify-search');
        const netlifySearchResults = document.getElementById('netlify-search-results');
        
        // Elements within YouTube Modal (matching selected HTML IDs)
        const youtubeUrlInputModal = document.getElementById('youtube-url-input-modal');
        const addFromUrlButton = document.getElementById('add-from-url-button');
        const youtubeTextSearchInput = document.getElementById('youtube-text-search-input');
        const performYoutubeTextSearchButton = document.getElementById('perform-youtube-text-search');
        const youtubeSearchResults = document.getElementById('youtube-search-results');
        
        const editablePlaylistContainer = document.getElementById('editable-playlist-container');
        const playlistEmptyMessage = document.getElementById('playlist-empty-message');

        // Jam Session Modals and Elements (matching selected HTML IDs)
        const createJamModal = document.getElementById('create-jam-modal');
        const jamNameInput = document.getElementById('jam-name-input'); // Matched ID with HTML
        const nicknameInputCreate = document.getElementById('nickname-input-create');
        const createJamButton = document.getElementById('create-jam-button');
        const shareLinkContainer = document.getElementById('share-link-container');
        const jamShareLinkInput = document.getElementById('jam-share-link');
        const copyShareLinkButton = document.getElementById('copy-share-link-button');

        const joinJamModal = document.getElementById('join-jam-modal');
        const joinJamNameDisplay = document.getElementById('join-jam-name-display');
        const nicknameInputJoin = document.getElementById('nickname-input-join');
        const joinJamIdInput = document.getElementById('join-jam-id-input'); // Explicitly added to HTML and JS
        const joinJamButton = document.getElementById('join-jam-button');

        const jamSessionInfoDiv = document.getElementById('jam-session-info'); // Main jam info display
        const jamNameDisplay = document.getElementById('jam-name-display'); // Nested span for jam name
        const jamParticipantsDisplay = document.getElementById('jam-participants-display'); // Nested span for participants
        const leaveJamSessionButton = document.getElementById('leave-jam-session-button');

        // Permissions Management section (from previous code, integrated here as it's in the HTML structure)
        const permissionsManagementDiv = document.getElementById('permissions-management');
        const participantsList = document.getElementById('participants-list'); // For general list of participants
        const permissionsList = document.getElementById('permissions-list'); // For host's permission controls


        const customMessageBox = document.getElementById('custom-message-box'); // Custom message box element
        const loadingOverlay = document.getElementById('loading-overlay'); // Loading overlay element

        // Confirmation Modal elements (from previous code, kept for utility)
        const confirmationModal = document.getElementById('confirmation-modal');
        const confirmationModalTitle = document.getElementById('confirmation-modal-title');
        const confirmationModalMessage = document.getElementById('confirmation-modal-message');
        const confirmYesBtn = document.getElementById('confirm-yes-btn');
        const confirmNoBtn = document.getElementById('confirm-no-btn');


        const playlist = []; // Main player local playlist. This is only used when NOT in a jam session.

        let currentTrackIndex = 0;
        let progressInterval;
        let syncInterval; // For host to send regular updates to Firestore

        let userId = null; // Firebase User ID
        let currentPlaybackTime = 0; // To store and sync playback time
        let isSeeking = false; // Flag to prevent sync during seeking
        let currentJamHostSid = null; // Store the host's Socket.IO SID


        // --- Firebase Auth Listener ---
        onAuthStateChanged(auth, (user) => {
            if (user) {
                userId = user.uid;
                console.log("Firebase authenticated. User ID:", userId);
                // Now that we have a user, proceed with app initialization or jam session logic
                handleInitialLoadAndJamJoin();

            } else {
                console.log("Firebase not authenticated. Signing in anonymously...");
                signInAnonymously(auth).then(() => {
                    console.log("Signed in anonymously.");
                    // After anonymous sign-in, Firebase will re-trigger onAuthStateChanged with a user.
                }).catch((error) => {
                    console.error("Anonymous sign-in failed:", error);
                    showMessage(`Authentication failed: ${error.message}. Jam features may not work.`, 6000);
                    // Disable jam features on critical Firebase auth failure if needed
                    if(createJamSessionDropdownBtn) createJamSessionDropdownBtn.disabled = true;
                    if(joinJamSessionDropdownBtn) joinJamSessionDropdownBtn.disabled = true;
                });
            }
        });

        // --- Hosted Songs Manifest Loading ---
        async function loadHostedSongsManifest() {
            try {
                const response = await fetch('hosted_songs_manifest.json'); // Assumes manifest is in the same directory
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                hostedSongsList = await response.json();
                console.log("Loaded hosted songs manifest:", hostedSongsList.length, "songs");
            } catch (error) {
                console.error("Error loading hosted_songs_manifest.json:", error);
                showMessage("Failed to load hosted songs manifest. Local MP3 search and random play may not work.", 6000);
            }
        }


        // --- Utility Functions ---
        function formatTime(seconds) {
            if (isNaN(seconds) || seconds < 0 || !isFinite(seconds)) return "0:00"; // Handle NaN/Infinity
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = Math.floor(seconds % 60);
            return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Displays a custom message box at the bottom of the screen.
         * @param {string} message - The message to display.
         * @param {number} duration - How long to display the message in milliseconds (0 for indefinite).
         */
        function showMessage(message, duration = 3000) {
            customMessageBox.textContent = message;
            customMessageBox.classList.remove('hidden');
            customMessageBox.classList.add('show');
            clearTimeout(customMessageBox.messageTimeout); // Clear any existing timeout
            if (duration > 0) {
                customMessageBox.messageTimeout = setTimeout(() => {
                    customMessageBox.classList.remove('show');
                    customMessageBox.classList.add('hidden');
                }, duration);
            }
        }

        function showLoading() {
            loadingOverlay.classList.remove('hidden');
        }

        function hideLoading() {
            loadingOverlay.classList.add('hidden');
        }

        function extractYouTubeVideoId(url) {
            let videoId = '';
            const youtubeRegex = /(?:https?:\/\/)?(?:www\.)?(?:m\.)?(?:youtube\.com|youtu\.be)\/(?:watch\?v=|embed\/|v\/|)([\w-]{11})(?:\S+)?/i;
            const match = url.match(youtubeRegex);
            if (match && match[1]) {
                videoId = match[1];
            }
            return videoId;
        }

        /**
         * Displays a custom confirmation dialog.
         * @param {string} title - The title of the confirmation dialog.
         * @param {string} message - The message body of the confirmation dialog.
         * @param {function(boolean): void} onConfirm - Callback function, called with true if confirmed, false otherwise.
         */
        function showConfirmation(title, message, onConfirm) {
            confirmationModalTitle.textContent = title;
            confirmationModalMessage.textContent = message;
            confirmationModal.classList.remove('hidden');

            const handleYes = () => {
                confirmationModal.classList.add('hidden');
                confirmYesBtn.removeEventListener('click', handleYes);
                confirmNoBtn.removeEventListener('click', handleNo);
                onConfirm(true);
            };

            const handleNo = () => {
                confirmationModal.classList.add('hidden');
                confirmYesBtn.removeEventListener('click', handleYes);
                confirmNoBtn.removeEventListener('click', handleNo);
                onConfirm(false);
            };

            confirmYesBtn.addEventListener('click', handleYes);
            confirmNoBtn.addEventListener('click', handleNo);
        }


        // --- YouTube API Integration ---
        // This function loads the YouTube IFrame API script.
        // It's called automatically by the YouTube API itself via the <script src="https://www.youtube.com/iframe_api">.
        // We ensure that the onYouTubeIframeAPIReady function is globally available for it to call.

        // This function is called automatically by the YouTube IFrame API when it is ready.
        window.onYouTubeIframeAPIReady = function() {
            youtubePlayer = new YT.Player('youtube-player-iframe', {
                height: '100%',
                width: '100%',
                videoId: '', // Initial video ID (empty)
                playerVars: {
                    'playsinline': 1,
                    'autoplay': 0, // Set to 0 to prevent issues with user gesture requirements
                    'controls': 0, // Custom controls via HTML/CSS
                    'disablekb': 1, // Disable keyboard controls
                    'fs': 0, // Disable fullscreen button
                    'iv_load_policy': 3, // Disable annotations
                    'modestbranding': 1, // Reduce YouTube branding
                    'rel': 0, // Disable related videos at end
                    'showinfo': 0, // Hide video title and uploader info
                    'start': 0 // Start time
                },
                events: {
                    'onReady': onPlayerReady,
                    'onStateChange': onPlayerStateChange,
                    'onError': onPlayerError
                }
            });
        }

        function onPlayerReady(event) {
            youtubePlayerReady = true;
            console.log("YouTube Player is ready.");
            // If in a jam session and YouTube player becomes ready, re-sync to current track if necessary.
            // This is primarily handled by the Firestore onSnapshot listener for jam sessions.
            if (currentJamId && jamSessionPlaylist.length > 0) {
                 const currentTrack = jamSessionPlaylist[currentTrackIndex];
                 if (currentTrack && currentTrack.type === 'youtube' && youtubePlayer.getVideoData().video_id !== currentTrack.videoId) {
                    // If the jam is playing a YouTube video, ensure this player reflects it
                    // The onSnapshot will likely trigger loadTrack, but this is a fallback
                    youtubePlayer.loadVideoById(currentTrack.videoId, currentPlaybackTime);
                    if (isHost && jamSessionPlaylist[currentTrackIndex].type === 'youtube') {
                        // Only play if host intended it and it's a YouTube track
                        if (youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                            youtubePlayer.playVideo();
                        }
                    } else if (!isHost && youtubePlayer.getPlayerState() !== YT.PlayerState.PLAYING) {
                        // Guests sync with host's playing state
                        // The onSnapshot handles playing/pausing
                    }
                 }
            } else if (!currentJamId && playlist.length > 0 && playlist[currentTrackIndex] && playlist[currentTrackIndex].type === 'youtube') {
                 // If not in a jam and current local track is YouTube, load it (but don't autoplay)
                loadTrack(currentTrackIndex, false); 
            }
        }

        function onPlayerStateChange(event) {
            const isCurrentlyPlaying = (event.data === YT.PlayerState.PLAYING);
            const isCurrentlyPaused = (event.data === YT.PlayerState.PAUSED || event.data === YT.PlayerState.ENDED);

            if (isCurrentlyPlaying) {
                playPauseIcon.classList.remove('fa-play');
                playPauseIcon.classList.add('fa-pause');
                playPauseButton.classList.add('is-playing');
                clearInterval(progressInterval);
                progressInterval = setInterval(updateProgressBar, 1000);
            } else if (isCurrentlyPaused) {
                playPauseIcon.classList.remove('fa-pause');
                playPauseIcon.classList.add('fa-play');
                playPauseButton.classList.remove('is-playing');
                clearInterval(progressInterval);
                if (event.data === YT.PlayerState.ENDED) {
                    if (!currentJamId || isHost || myPermissions.play) { // Ensure play permission or host for next track
                        playNextTrack();
                    }
                }
            }
            // Host updates Firestore whenever playback state changes
            if (currentJamId && isHost) {
                updateFirestorePlaybackState();
            }
        }

        function onPlayerError(event) {
            console.error("YouTube Player Error:", event.data);
            showMessage(`YouTube playback error (${event.data}). Skipping to next song.`, 4000);
            if (!currentJamId || isHost || myPermissions.play) { // Ensure play permission or host
                playNextTrack(); // Host or local player controls next track
            }
        }

        // --- Core Player Functions ---
        /**
         * Loads and (optionally) plays a track from the current active playlist.
         * Handles both audio (MP3/Netlify) and YouTube video types.
         * @param {number} index - The index of the track in the active playlist.
         * @param {boolean} autoPlay - Whether to automatically start playing the track.
         */
        async function loadTrack(index, autoPlay = true) {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;

            if (index < 0 || index >= activePlaylist.length) {
                console.warn("Invalid track index or playlist is empty. Resetting player.");
                resetPlayerUI();
                return;
            }

            // Remove 'current-song' class from previously active playlist item
            const currentActive = document.querySelector('.playlist-item.current-song');
            if (currentActive) {
                currentActive.classList.remove('current-song');
            }

            currentTrackIndex = index;
            const track = activePlaylist[currentTrackIndex];

            trackTitle.textContent = track.title;
            artistName.textContent = track.artist || track.uploader || 'Unknown Artist'; // Use uploader for YouTube
            albumArt.src = track.albumArtSrc || track.thumbnail || "https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Track";
            albumArt.onerror = () => {
                albumArt.src = "https://placehold.co/128x128/CCCCCC/FFFFFF?text=Error"; // Fallback on image load error
            };

            // Ensure only one player display is visible and media is paused before loading new
            youtubeIframeDiv.classList.add('hidden');
            albumArt.classList.remove('hidden');
            audioPlayer.pause();
            if (youtubePlayer && youtubePlayerReady) youtubePlayer.pauseVideo();
            
            // Reset button states
            playPauseIcon.classList.remove('fa-pause');
            playPauseIcon.classList.add('fa-play');
            playPauseButton.classList.remove('is-playing');


            if (track.type === 'audio') { // For generic audio files (like hosted MP3s)
                audioPlayer.src = track.url; // Use 'url' for hosted audio files
                audioPlayer.load();
                if (autoPlay) {
                    audioPlayer.play().catch(e => console.error("Error playing audio (type:audio):", e));
                    playPauseButton.classList.add('is-playing');
                }
                clearInterval(progressInterval);
                progressInterval = setInterval(updateProgressBar, 1000);

            } else if (track.type === 'youtube') { // For direct YouTube video playback
                albumArt.classList.add('hidden');
                youtubeIframeDiv.classList.remove('hidden');

                if (youtubePlayerReady) {
                    youtubePlayer.loadVideoById(track.videoId, 0); // Load and play from start
                    if (autoPlay) {
                        youtubePlayer.playVideo();
                        // State change handler will update playPauseIcon and is-playing class
                    }
                } else {
                    console.warn("YouTube player not ready, cannot play video yet.");
                    showMessage("YouTube player is still loading. Please try again in a moment.", 3000);
                }

            } else if (track.type === 'youtube_download') { // For YouTube videos requiring backend download
                showMessage(`Downloading "${track.title}"...`, 0); // Show indefinite message
                showLoading(); // Show global loading spinner
                playPauseButton.classList.remove('is-playing'); // Ensure button shows paused state
                try {
                    const response = await fetch(`${FLASK_BACKEND_URL}/download_youtube_audio/${track.videoId}`);
                    const data = await response.json();
                    hideLoading(); // Hide global loading spinner

                    if (response.ok) {
                        const downloadedAudioUrl = data.audio_url;
                        const newTrack = {
                            id: track.id, // Keep original ID
                            type: "audio", // Now it's a local audio file
                            title: track.title,
                            artist: track.artist,
                            url: downloadedAudioUrl, // Use 'url' for audio source
                            albumArtSrc: track.albumArtSrc,
                            duration: track.duration // Retain duration if available
                        };
                        
                        // Update the track in the active playlist (either jamSessionPlaylist or local playlist)
                        const targetPlaylist = currentJamId ? jamSessionPlaylist : playlist;
                        const originalIndex = targetPlaylist.findIndex(t => t.id === track.id);
                        if (originalIndex !== -1) {
                            targetPlaylist[originalIndex] = newTrack;
                            if (currentJamId && isHost) {
                                // If host, update the Firestore playlist so others get the new track info
                                await updateDoc(doc(db, 'jam_sessions', currentJamId), {
                                    playlist: targetPlaylist
                                });
                            }
                        }
                        
                        showMessage(`Finished downloading "${track.title}". Now playing.`, 3000);
                        // Recursively call loadTrack with the new 'audio' type track at the same index
                        loadTrack(currentTrackIndex, autoPlay); 
                        renderPlaylist(); // Re-render playlist to reflect the type change
                    } else {
                        showMessage(`Error downloading "${track.title}": ${data.error || 'Unknown error'}`, 5000);
                        if (!currentJamId || isHost || myPermissions.play) { // If host or has play permission, skip
                            playNextTrack(); 
                        } else {
                            resetPlayerUI(); // If guest and no permission, just reset
                        }
                    }
                } catch (error) {
                    hideLoading();
                    console.error("Error during YouTube audio download request:", error);
                    showMessage(`Network error during download: ${error.message}`, 5000);
                    if (!currentJamId || isHost || myPermissions.play) { // If host or has play permission, skip
                        playNextTrack(); 
                    } else {
                        resetPlayerUI();
                    }
                }
            } else {
                console.warn("Unknown track type:", track.type);
                showMessage("Unsupported track type. Skipping.", 3000);
                if (!currentJamId || isHost || myPermissions.play) {
                    playNextTrack();
                } else {
                    resetPlayerUI();
                }
                return;
            }
            
            // Add 'current-song' class to the newly active playlist item
            const newActive = document.getElementById(`playlist-item-${index}`);
            if (newActive) {
                newActive.classList.add('current-song');
            }
        }

        // --- Audio Player Event Handlers ---
        audioPlayer.addEventListener('timeupdate', () => {
            if (!isSeeking) { // Only update progress bar if not actively seeking
                updateProgressBar();
            }
        });

        audioPlayer.addEventListener('ended', () => {
            if (!currentJamId || isHost || myPermissions.play) { // Only host or privileged user advances
                playNextTrack();
            }
        });

        audioPlayer.addEventListener('play', () => {
            // Handled by onPlayerStateChange for YouTube, directly for local audio
            playPauseIcon.classList.remove('fa-play');
            playPauseIcon.classList.add('fa-pause');
            playPauseButton.classList.add('is-playing');
            if (currentJamId && isHost) updateFirestorePlaybackState(true);
        });

        audioPlayer.addEventListener('pause', () => {
            // Handled by onPlayerStateChange for YouTube, directly for local audio
            playPauseIcon.classList.remove('fa-pause');
            playPauseIcon.classList.add('fa-play');
            playPauseButton.classList.remove('is-playing');
            if (currentJamId && isHost) updateFirestorePlaybackState(false);
        });

        audioPlayer.addEventListener('volumechange', () => {
            // Sync both sliders
            volumeBar.value = audioPlayer.volume * 100;
            volumeBar.style.setProperty('--volume', `${volumeBar.value}%`); // FIXED: Incomplete setProperty
            // There's only one HTML player (audioPlayer). youtubePlayer uses its own volume.
            // If youtubePlayer exists, also sync its volume for UI consistency.
            if (youtubePlayerReady && youtubePlayer) { // Ensure youtubePlayer exists before setting volume
                youtubePlayer.setVolume(volumeBar.value); // YouTube Player volume is 0-100
            }
        });

        /**
         * Updates the progress bar and time displays for the currently active player.
         */
        function updateProgressBar() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];
            if (!currentTrack) return;

            let progress = 0;
            let duration = 0;
            let currentTime = 0;

            if (currentTrack.type === 'audio') {
                currentTime = audioPlayer.currentTime;
                duration = audioPlayer.duration;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                currentTime = youtubePlayer.getCurrentTime();
                duration = youtubePlayer.getDuration();
            }

            if (duration > 0 && isFinite(duration)) {
                progress = (currentTime / duration) * 100;
            }

            progressBar.value = progress;
            progressBar.style.setProperty('--progress', `${progress}%`);
            currentTimeSpan.textContent = formatTime(currentTime);
            totalTimeSpan.textContent = formatTime(duration);
        }

        /**
         * Checks if the currently playing media is ready for seeking (e.g., loaded enough).
         * @returns {boolean} True if ready, false otherwise.
         */
        function isMediaReadyForSeek() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];
            if (!currentTrack) {
                showMessage("No song loaded.", 2000);
                return false;
            }

            let mediaDuration = 0;
            let ready = false;

            if (currentTrack.type === 'audio') {
                if (audioPlayer.readyState >= 3) { // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA
                    mediaDuration = audioPlayer.duration;
                    ready = !isNaN(mediaDuration) && isFinite(mediaDuration) && mediaDuration > 0;
                }
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                const playerState = youtubePlayer.getPlayerState();
                // Ready states for YouTube are PLAYING, PAUSED, BUFFERING. UNSTARTED, CUED mean not ready.
                if (playerState !== YT.PlayerState.UNSTARTED && playerState !== YT.PlayerState.CUED) {
                    mediaDuration = youtubePlayer.getDuration();
                    ready = !isNaN(mediaDuration) && isFinite(mediaDuration) && mediaDuration > 0;
                }
            }
            if (!ready) {
                console.warn("Media not ready for seek/jump. Current duration:", mediaDuration);
                showMessage("Media is still loading. Please wait.", 2000);
            }
            return ready;
        }

        // --- Playback Controls Event Listeners ---

        playPauseButton.addEventListener('click', () => {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            if (!currentTrack) {
                showMessage("Playlist is empty. Add songs first!", 3000);
                return;
            }

            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }

            let newIsPlaying;
            if (currentTrack.type === 'audio') {
                if (audioPlayer.paused) {
                    audioPlayer.play().catch(e => console.error("Error playing audio:", e));
                    newIsPlaying = true;
                } else {
                    audioPlayer.pause();
                    newIsPlaying = false;
                }
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                if (youtubePlayer.getPlayerState() === YT.PlayerState.PAUSED || youtubePlayer.getPlayerState() === YT.PlayerState.ENDED || youtubePlayer.getPlayerState() === YT.PlayerState.BUFFERING) {
                    youtubePlayer.playVideo();
                    newIsPlaying = true;
                } else {
                    youtubePlayer.pauseVideo();
                    newIsPlaying = false;
                }
            } else if (currentTrack.type === 'youtube_download') {
                showMessage("Please wait for the audio to download before playing.", 3000);
                return;
            } else {
                showMessage("Unsupported track type.", 3000);
                return;
            }

            if (currentJamId && isHost) {
                updateFirestorePlaybackState(newIsPlaying); // Sync state after host action
            }
        });

        rewindButton.addEventListener('click', () => {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            if (!currentTrack) return;
            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }
            if (!isMediaReadyForSeek()) { return; }

            let currentMediaTime = 0;
            if (currentTrack.type === 'audio') {
                currentMediaTime = audioPlayer.currentTime;
                audioPlayer.currentTime = Math.max(0, currentMediaTime - 10);
            } else if (currentTrack.type === 'youtube' && youtubePlayer && youtubePlayerReady) {
                currentMediaTime = youtubePlayer.getCurrentTime();
                youtubePlayer.seekTo(Math.max(0, currentMediaTime - 10), true);
            }
            if (currentJamId && isHost) {
                updateFirestorePlaybackState(); // Sync state after host action
            }
        });

        forwardButton.addEventListener('click', () => {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            if (!currentTrack) return;
            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }
            if (!isMediaReadyForSeek()) { return; }

            let currentMediaTime = 0;
            let mediaDuration = 0;
            if (currentTrack.type === 'audio') {
                currentMediaTime = audioPlayer.currentTime;
                mediaDuration = audioPlayer.duration;
                audioPlayer.currentTime = Math.min(mediaDuration, currentMediaTime + 10);
            } else if (currentTrack.type === 'youtube' && youtubePlayer && youtubePlayerReady) {
                currentMediaTime = youtubePlayer.getCurrentTime();
                mediaDuration = youtubePlayer.getDuration();
                youtubePlayer.seekTo(Math.min(mediaDuration, currentMediaTime + 10), true);
            }
            if (currentJamId && isHost) {
                updateFirestorePlaybackState(); // Sync state after host action
            }
        });

        nextButton.addEventListener('click', () => {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            if (activePlaylist.length === 0) {
                showMessage("Playlist is empty. Cannot skip.", 2000);
                return;
            }
            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }

            if (isPlayingRandomNetlifyMode) { // Changed to Netlify mode
                playNextTrack(); // This handles random playlist logic, also updates Firestore
            } else {
                let nextIndex = currentTrackIndex + 1;
                if (nextIndex >= activePlaylist.length) {
                    nextIndex = 0; // Loop back to the beginning
                }
                loadTrack(nextIndex, true);
                if (currentJamId && isHost) {
                    updateFirestorePlaybackState(true, nextIndex, 0); // Force sync new index and time
                }
            }
        });

        progressBar.addEventListener('input', () => { // Update progress on slider change (during drag)
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            if (!currentTrack) return;
            // No permission check here, as user is just dragging locally. Sync happens on mouseup.
            
            let player;
            let totalDuration;

            if (currentTrack.type === 'audio') {
                player = audioPlayer;
                totalDuration = audioPlayer.duration;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                player = youtubePlayer;
                totalDuration = youtubePlayer.getDuration();
            } else { return; }

            const seekTime = (progressBar.value / 100) * totalDuration;
            currentTimeSpan.textContent = formatTime(seekTime); // Update displayed time
        });

        progressBar.addEventListener('mousedown', () => isSeeking = true); // Set seeking flag
        progressBar.addEventListener('mouseup', (e) => { // When user releases slider
            isSeeking = false;
            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }
            if (!isMediaReadyForSeek()) { return; }

            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const currentTrack = activePlaylist[currentTrackIndex];

            let player;
            let totalDuration;

            if (currentTrack.type === 'audio') {
                player = audioPlayer;
                totalDuration = audioPlayer.duration;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                player = youtubePlayer;
                totalDuration = youtubePlayer.getDuration();
            } else { return; }

            const seekTime = (e.target.value / 100) * totalDuration;
            if (currentTrack.type === 'audio') {
                player.currentTime = seekTime;
            } else {
                player.seekTo(seekTime, true);
            }
            if (currentJamId && isHost) {
                updateFirestorePlaybackState(); // Sync state after host action
            }
        });

        volumeBar.addEventListener('input', () => {
            const volume = volumeBar.value / 100;
            audioPlayer.volume = volume;
            if (youtubePlayerReady && youtubePlayer) { // Ensure youtubePlayer exists before setting volume
                youtubePlayer.setVolume(volumeBar.value); // YouTube Player volume is 0-100
            }
            volumeBar.style.setProperty('--volume', `${volumeBar.value}%`);
        });

        // --- Playlist Management Functions ---
        function renderPlaylist() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            playlistContainer.innerHTML = '';
            if (activePlaylist.length === 0) {
                playlistContainer.innerHTML = '<p class="text-center text-gray-500">Playlist is empty. Add songs!</p>';
                return;
            }
            activePlaylist.forEach((track, index) => {
                const li = document.createElement('li');
                // Added id for easier selection in loadTrack
                li.className = `playlist-item flex items-center space-x-3 p-2 rounded-lg cursor-pointer hover:bg-gray-100 transition-colors duration-150 ${index === currentTrackIndex ? 'current-song' : ''}`;
                li.dataset.index = index;
                li.id = `playlist-item-${index}`; // Unique ID for each playlist item
                
                // Determine if item is clickable for playback based on permissions
                const isPlayable = (!currentJamId || isHost || myPermissions.play);
                if (!isPlayable) {
                    li.classList.add('opacity-70', 'cursor-not-allowed');
                }

                li.innerHTML = `
                    <img src="${track.albumArtSrc || track.thumbnail || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=MP3'}" alt="Album Art" class="w-10 h-10 object-cover rounded-md shadow-sm flex-shrink-0">
                    <div class="flex-grow min-w-0">
                        <p class="text-sm font-semibold text-gray-800 truncate">${track.title}</p>
                        <p class="text-xs text-gray-600 truncate">${track.artist || track.uploader || 'Unknown Artist'}</p>
                    </div>
                `;
                li.addEventListener('click', () => {
                    if (!isPlayable) {
                        showMessage("You do not have permission to play songs in this jam.", 3000);
                        return;
                    }
                    if (isPlayingRandomNetlifyMode) { // Changed to Netlify mode
                        isPlayingRandomNetlifyMode = false;
                        showMessage("Random play mode disabled. Playing selected song.", 3000);
                    }
                    loadTrack(index, true); // Play the selected track
                    if (currentJamId && isHost) {
                        // Host updates Firestore with new track index and resets playback time
                        updateFirestorePlaybackState(true, index, 0); 
                    }
                });
                playlistContainer.appendChild(li);
            });
            updatePlaylistHighlight(); // Ensure highlight is applied correctly
        }

        function renderEditablePlaylist() {
            editablePlaylistContainer.innerHTML = '';
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;

            if (activePlaylist.length === 0) {
                playlistEmptyMessage.classList.remove('hidden');
                return;
            }
            playlistEmptyMessage.classList.add('hidden');
            activePlaylist.forEach((track, index) => {
                const li = document.createElement('li');
                // Check for remove permission
                const isRemovable = (!currentJamId || isHost || myPermissions.remove);
                li.className = `flex items-center space-x-2 p-2 rounded-lg border border-gray-200 mb-2 ${!isRemovable ? 'opacity-70 cursor-not-allowed' : ''}`;
                li.innerHTML = `
                    <img src="${track.albumArtSrc || track.thumbnail || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=MP3'}" alt="Album Art" class="w-10 h-10 object-cover rounded-md shadow-sm flex-shrink-0">
                    <div class="flex-grow min-w-0">
                        <p class="text-sm font-semibold text-gray-800 truncate">${track.title}</p>
                        <p class="text-xs text-gray-600 truncate">${track.artist || track.uploader || 'Unknown Artist'}</p>
                    </div>
                    <button class="remove-song-btn text-red-500 hover:text-red-700 focus:outline-none ml-2 flex-shrink-0" data-index="${index}" ${!isRemovable ? 'disabled' : ''}>
                        <i class="fas fa-trash"></i>
                    </button>
                `;
                editablePlaylistContainer.appendChild(li);
            });

            editablePlaylistContainer.querySelectorAll('.remove-song-btn').forEach(button => {
                button.addEventListener('click', async (event) => {
                    const indexToRemove = parseInt(event.currentTarget.dataset.index);
                    if (currentJamId && !isHost && !myPermissions.remove) {
                        showMessage("You do not have permission to remove songs from this jam.", 3000);
                        return;
                    }
                    showConfirmation(
                        "Remove Song?",
                        `Are you sure you want to remove "${activePlaylist[indexToRemove].title}" from the playlist?`,
                        async (confirmed) => {
                            if (confirmed) {
                                await removeSongFromPlaylist(indexToRemove);
                            }
                        }
                    );
                });
            });
        }

        async function removeSongFromPlaylist(index) {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;

            if (index > -1 && index < activePlaylist.length) {
                const removedTrack = activePlaylist.splice(index, 1)[0];
                showMessage(`Removed "${removedTrack.title}" from playlist.`, 3000);

                if (currentJamId && isHost) {
                    try {
                        // Update Firestore directly
                        await updateDoc(doc(db, 'jam_sessions', currentJamId), {
                            playlist: activePlaylist // Send the updated playlist array
                        });
                        // The Firestore onSnapshot listener will then update all clients
                    } catch (e) {
                        console.error("Error removing song from Firestore playlist:", e);
                        showMessage("Error removing song from jam session. Please try again.", 3000);
                    }
                }

                // Adjust playback state if currently playing song was removed or shifted
                if (currentTrackIndex === index) {
                    if (activePlaylist.length > 0) {
                        loadTrack(Math.min(index, activePlaylist.length - 1), true); // Play next or previous
                    } else {
                        resetPlayerUI(); // Playlist is empty
                    }
                } else if (currentTrackIndex > index) {
                    currentTrackIndex--; // Shift index if a song before it was removed
                }

                renderPlaylist();
                renderEditablePlaylist(); // Update manage playlist modal too
            }
        }

        function resetPlayerUI() {
            audioPlayer.pause();
            audioPlayer.src = '';
            if (youtubePlayer && youtubePlayerReady) youtubePlayer.stopVideo(); // Stop YouTube player
            trackTitle.textContent = 'No song loaded'; // Changed from 'Song Title Goes Here' for clarity
            artistName.textContent = ''; // Changed from 'Artist Name' for clarity
            albumArt.src = "https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Track"; // Generic no track image
            clearInterval(progressInterval);
            currentTimeSpan.textContent = "0:00";
            totalTimeSpan.textContent = "0:00";
            progressBar.value = 0;
            progressBar.style.setProperty('--progress', `0%`);
            playPauseIcon.classList.remove('fa-pause');
            playPauseIcon.classList.add('fa-play');
            playPauseButton.classList.remove('is-playing');
            youtubeIframeDiv.classList.add('hidden');
            albumArt.classList.remove('hidden');
        }

        function updatePlaylistHighlight() {
            const items = playlistContainer.querySelectorAll('li');
            items.forEach((item, index) => {
                if (index === currentTrackIndex) {
                    item.classList.add('current-song');
                } else {
                    item.classList.remove('current-song');
                }
            });
        }

        // --- Modal & Section Control Functions ---
        function openYoutubeModal() {
            console.log("Opening YouTube Modal");
            youtubeModal.classList.remove('hidden');
            youtubeUrlInputModal.value = ''; // Clear input on open
            youtubeTextSearchInput.value = ''; // Clear input on open
            youtubeSearchResults.innerHTML = ''; // Clear previous results
            // Ensure other modals/sections are closed
            hideNetlifySearchSection(); // New: Hide Netlify section
            closeManagePlaylistModal();
            closeCreateJamModal();
            closeJoinJamModal();
        }

        function closeYoutubeModal() {
            console.log("Closing YouTube Modal");
            youtubeModal.classList.add('hidden');
        }

        // New functions to show/hide Netlify search section on the main page
        function showNetlifySearchSection() {
            console.log("Showing Netlify Search Section");
            netlifySearchSection.classList.remove('hidden');
            netlifySearchInput.value = ''; // Clear input on open
            netlifySearchResults.innerHTML = ''; // Clear previous results
            // Ensure other modals are closed
            closeYoutubeModal();
            closeManagePlaylistModal();
            closeCreateJamModal();
            closeJoinJamModal();
        }

        function hideNetlifySearchSection() {
            console.log("Hiding Netlify Search Section");
            netlifySearchSection.classList.add('hidden');
        }

        function openManagePlaylistModal() {
            console.log("Opening Manage Playlist Modal");
            managePlaylistModal.classList.remove('hidden');
            renderEditablePlaylist(); // Populate editable playlist
            // Ensure other modals/sections are closed
            closeYoutubeModal();
            hideNetlifySearchSection(); // New: Hide Netlify section
            closeCreateJamModal();
            closeJoinJamModal();
        }

        function closeManagePlaylistModal() {
            console.log("Closing Manage Playlist Modal");
            managePlaylistModal.classList.add('hidden');
        }

        function openCreateJamModal() {
            console.log("Opening Create Jam Modal");
            createJamModal.classList.remove('hidden');
            jamNameInput.value = '';
            shareLinkContainer.classList.add('hidden'); // Hide link until created
            jamShareLinkInput.value = '';
            // Ensure other modals/sections are closed
            closeYoutubeModal();
            hideNetlifySearchSection(); // New: Hide Netlify section
            closeManagePlaylistModal();
            closeJoinJamModal();
        }

        function closeCreateJamModal() {
            console.log("Closing Create Jam Modal");
            createJamModal.classList.add('hidden');
        }

        async function openJoinJamModal(jamIdFromUrl, jamNamePlaceholder) {
            console.log(`Opening Join Jam Modal for ID: ${jamIdFromUrl}`);
            joinJamModal.classList.remove('hidden');
            // Pre-fill ID if available from URL
            if (jamIdFromUrl) {
                joinJamIdInput.value = jamIdFromUrl;
            } else {
                joinJamIdInput.value = '';
            }
            joinJamNameDisplay.textContent = `Joining: ${jamNamePlaceholder}`;
            nicknameInputJoin.value = 'Anonymous Listener'; // Default nickname

            // Optional: Fetch actual jam name from Firestore if it exists and is active
            if (db && jamIdFromUrl) { // Only fetch if there's a jamId to fetch
                try {
                    const jamDoc = await getDoc(doc(db, 'jam_sessions', jamIdFromUrl));
                    if (jamDoc.exists && jamDoc.data().is_active) {
                        joinJamNameDisplay.textContent = `Joining: ${jamDoc.data().name || jamNamePlaceholder}`;
                    } else {
                        joinJamNameDisplay.textContent = `Session ${jamIdFromUrl} (Not Found or Inactive)`;
                        showMessage(`Jam session ${jamIdFromUrl} not found or is inactive.`, 5000);
                        // Do not close modal automatically, let user correct ID or nickname
                    }
                } catch (e) {
                    console.error("Error fetching jam name for join modal:", e);
                    joinJamNameDisplay.textContent = `Session ${jamIdFromUrl} (Error Loading)`;
                    showMessage("Error retrieving jam details.", 5000);
                    // Do not close modal automatically
                }
            }
            // Ensure other modals/sections are closed
            closeYoutubeModal();
            hideNetlifySearchSection(); // New: Hide Netlify section
            closeManagePlaylistModal();
            closeCreateJamModal();
        }

        function closeJoinJamModal() {
            console.log("Closing Join Jam Modal");
            joinJamModal.classList.add('hidden');
            // currentJamId is not cleared here; it's set on successful join or when leaving a jam.
        }

        // --- Expose modal/section functions to window for inline onclicks ---
        window.closeYoutubeModal = closeYoutubeModal;
        window.closeManagePlaylistModal = closeManagePlaylistModal;
        window.closeCreateJamModal = closeCreateJamModal;
        window.closeJoinJamModal = closeJoinJamModal;


        // --- Add Song Functions ---
        async function getYouTubeVideoDetails(videoId) {
            try {
                showLoading();
                const response = await fetch(`${FLASK_BACKEND_URL}/youtube_info?url=https://www.youtube.com/watch?v=${videoId}`);
                const data = await response.json();
                hideLoading();
                if (response.ok && data) {
                    return {
                        id: data.video_id, // Consistent ID for all tracks
                        title: data.title,
                        artist: data.uploader,
                        albumArtSrc: data.thumbnail || `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
                        type: "youtube",
                        videoId: data.video_id,
                        duration: data.duration // Include duration if available
                    };
                } else {
                    showMessage(`Could not find video details for ID: ${videoId}`, 4000);
                    return null;
                }
            } catch (error) {
                hideLoading();
                console.error("Error fetching YouTube video details:", error);
                showMessage(`Error fetching YouTube video details: ${error.message}`, 5000);
                return null;
            }
        }

        async function searchYouTubeVideos(query) {
            try {
                showLoading();
                const response = await fetch(`${FLASK_BACKEND_URL}/Youtube?query=${encodeURIComponent(query)}`);
                const data = await response.json();
                hideLoading();
                if (response.ok && data.length > 0) {
                    return data.map(item => ({
                        id: item.id, // YouTube video ID is the unique ID
                        type: "youtube_download", // Indicates it needs to be downloaded via Flask to become 'audio'
                        title: item.title,
                        artist: item.uploader,
                        videoId: item.id,
                        albumArtSrc: item.thumbnail || `https://img.youtube.com/vi/${item.id}/hqdefault.jpg`,
                        duration: item.duration // Include duration if available
                    }));
                } else {
                    showMessage("No YouTube videos found for your search query.", 3000);
                    return [];
                }
            } catch (error) {
                hideLoading();
                console.error("Error searching YouTube videos:", error);
                showMessage(`Error searching YouTube: ${error.message}`, 5000);
                return [];
            }
        }

        /**
         * Searches local hosted MP3s from the manifest.
         * @param {string} query - The search query.
         * @returns {Array} Filtered list of songs.
         */
        function searchNetlifyMp3s(query) {
            if (!hostedSongsList || hostedSongsList.length === 0) {
                showMessage("No hosted songs loaded. Please check manifest.", 3000);
                return [];
            }
            const lowerCaseQuery = query.toLowerCase();
            return hostedSongsList.filter(song =>
                (song.title && song.title.toLowerCase().includes(lowerCaseQuery)) ||
                (song.artist && song.artist.toLowerCase().includes(lowerCaseQuery))
            );
        }

        /**
         * Renders search results from Netlify hosted MP3s.
         * @param {Array} results - Array of song objects.
         * @param {HTMLElement} targetContainer - The DOM element to render results into.
         */
        function renderNetlifySearchResults(results, targetContainer) {
            targetContainer.innerHTML = '';
            if (results.length === 0) {
                targetContainer.innerHTML = '<p class="text-center text-gray-500 py-4">No songs found matching your query.</p>';
                return;
            }
            results.forEach(song => {
                const resultItem = document.createElement('div');
                resultItem.classList.add('flex', 'items-center', 'space-x-3', 'p-2', 'bg-gray-50', 'rounded-lg', 'shadow-sm');
                const thumb = document.createElement('img');
                thumb.src = song.thumbnail || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=MP3';
                thumb.alt = 'Song thumbnail';
                thumb.classList.add('w-10', 'h-10', 'rounded-md', 'object-cover', 'flex-shrink-0');
                const textContent = document.createElement('div');
                textContent.classList.add('flex-grow', 'truncate');
                textContent.innerHTML = `<span class="font-medium block truncate">${song.title}</span><span class="text-xs text-gray-500 block truncate">${song.artist}</span>`;
                const addButton = document.createElement('button');
                const canAdd = (!currentJamId || isHost || myPermissions.add);
                addButton.classList.add('ml-2', 'px-3', 'py-1', 'bg-green-500', 'text-white', 'rounded-md', 'hover:bg-green-600', 'transition-colors', 'duration-200', 'flex-shrink-0', `${!canAdd ? 'opacity-70 cursor-not-allowed' : ''}`);
                addButton.innerHTML = '<i class="fas fa-plus mr-1"></i>Add';
                addButton.disabled = !canAdd;

                addButton.addEventListener('click', () => {
                    if (!canAdd) {
                        showMessage("You do not have permission to add songs to this jam.", 3000);
                        return;
                    }
                    if (isPlayingRandomNetlifyMode) { // Changed to Netlify mode
                        isPlayingRandomNetlifyMode = false;
                        showMessage("Random play mode disabled. Adding song to playlist.", 3000);
                    }
                    addSongToCurrentPlaylist(song);
                    // Optionally hide search section after adding a song
                    // hideNetlifySearchSection(); // Uncomment if you want to hide immediately after adding
                });
                resultItem.appendChild(thumb);
                resultItem.appendChild(textContent);
                resultItem.appendChild(addButton);
                targetContainer.appendChild(resultItem);
            });
        }


        // Renders search results from YouTube (for youtube-modal)
        function renderYouTubeSearchResults(results) {
            youtubeSearchResults.innerHTML = '';
            if (results.length === 0) {
                youtubeSearchResults.innerHTML = '<p class="text-center text-gray-500 py-4">No results found.</p>';
                return;
            }
            results.forEach(video => {
                const resultItem = document.createElement('div');
                resultItem.classList.add('flex', 'items-center', 'space-x-3', 'p-2', 'bg-gray-50', 'rounded-lg', 'shadow-sm');
                const thumb = document.createElement('img');
                thumb.src = video.albumArtSrc || 'https://placehold.co/40x40/CCCCCC/FFFFFF?text=Thumb'; // Fallback
                thumb.alt = 'Video thumbnail';
                thumb.classList.add('w-10', 'h-10', 'rounded-md', 'object-cover', 'flex-shrink-0');
                const textContent = document.createElement('div');
                textContent.classList.add('flex-grow', 'truncate');
                textContent.innerHTML = `<span class="font-medium block truncate">${video.title}</span><span class="text-xs text-gray-500 block truncate">${video.artist}</span>`;
                const addButton = document.createElement('button');
                // Permission check for adding to playlist (host or has 'add' permission)
                const canAdd = (!currentJamId || isHost || myPermissions.add);
                addButton.classList.add('ml-2', 'px-3', 'py-1', 'bg-green-500', 'text-white', 'rounded-md', 'hover:bg-green-600', 'transition-colors', 'duration-200', 'flex-shrink-0', `${!canAdd ? 'opacity-70 cursor-not-allowed' : ''}`);
                addButton.innerHTML = '<i class="fas fa-plus mr-1"></i>Add';
                addButton.disabled = !canAdd;

                addButton.addEventListener('click', () => {
                    if (!canAdd) {
                        showMessage("You do not have permission to add songs to this jam.", 3000);
                        return;
                    }
                    if (isPlayingRandomNetlifyMode) { // If currently in random play, adding a specific song means ending random mode
                        isPlayingRandomNetlifyMode = false;
                        showMessage("Random play mode disabled. Adding search results to playlist.", 3000);
                    }
                    addSongToCurrentPlaylist(video);
                });
                resultItem.appendChild(thumb);
                resultItem.appendChild(textContent);
                resultItem.appendChild(addButton);
                youtubeSearchResults.appendChild(resultItem);
            });
        }

        // Unified function to add song to either local playlist or jam session playlist
        async function addSongToCurrentPlaylist(song) {
            // Assign a unique ID if missing
            if (!song.id) {
                song.id = 'song_' + Date.now() + Math.random().toString(36).substring(2, 9);
            }

            if (currentJamId && isHost) {
                // Add to jamSessionPlaylist (local copy) and then update Firestore
                jamSessionPlaylist.push(song);
                try {
                    await updateDoc(doc(db, 'jam_sessions', currentJamId), {
                        playlist: jamSessionPlaylist // Send the updated array
                    });
                    showMessage(`Added "${song.title}" to Jam Session playlist!`, 2000);
                } catch (e) {
                    console.error("Error adding song to Firestore jam playlist:", e);
                    showMessage("Error adding song to jam session. Please try again.", 3000);
                }
            } else {
                playlist.push(song);
                renderPlaylist(); // Re-render the main local playlist
                showMessage(`Added "${song.title}" to your local playlist!`, 2000);
            }
        }

        // --- Random Playback Functions (for Netlify Hosted MP3s) ---
        async function startDynamicRandomPlaybackNetlify() { // Renamed function
            if (currentJamId && !isHost && !myPermissions.add) { // Assuming random play adds to playlist, so needs 'add' perm
                showMessage("You do not have permission to initiate random playback in a Jam Session.", 3000);
                return;
            }
            isPlayingRandomNetlifyMode = true; // Changed to Netlify mode
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            activePlaylist.length = 0; // Clear existing playlist

            if (hostedSongsList.length === 0) {
                showMessage("No hosted songs available to start random playback. Please load manifest.", 5000);
                resetPlayerUI();
                isPlayingRandomNetlifyMode = false;
                return;
            }

            const initialQueueSize = Math.min(RANDOM_QUEUE_SIZE, hostedSongsList.length);
            for (let i = 0; i < initialQueueSize; i++) {
                const newSong = getUniqueRandomSongFromHostedList(); // This also handles adding to the `activePlaylist`
                if (newSong) {
                    activePlaylist.push(newSong);
                } else {
                    break;
                }
            }
            shuffleArray(activePlaylist); // Shuffle the initial batch

            if (currentJamId && isHost) {
                // If host, update Firestore playlist and sync state
                try {
                    await updateDoc(doc(db, 'jam_sessions', currentJamId), {
                        playlist: activePlaylist,
                        'playback_state.current_track_index': 0, // Always play the first song in random queue
                        'playback_state.current_playback_time': 0,
                        'playback_state.is_playing': true,
                        'playback_state.timestamp': Date.now() / 1000
                    });
                } catch (e) {
                    console.error("Error starting random playback in Firestore:", e);
                    showMessage("Error starting random playback in jam session. Please try again.", 3000);
                }
            }

            renderPlaylist();
            if (activePlaylist.length > 0) {
                currentTrackIndex = 0;
                loadTrack(currentTrackIndex, true);
                showMessage(`Starting random play with ${activePlaylist.length} songs!`, 3000);
            } else {
                showMessage("Could not populate initial random queue.", 3000);
                resetPlayerUI();
                isPlayingRandomNetlifyMode = false;
            }
        }
        
        /**
         * Gets a unique random song from the full hosted list that is not currently in the active playlist.
         * If all unique songs are in the playlist, it will start re-using songs.
         * @returns {Object|null} A random song object or null if no songs are available.
         */
        function getUniqueRandomSongFromHostedList() { // Renamed function
            if (hostedSongsList.length === 0) {
                return null;
            }
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            const availableSongs = hostedSongsList.filter(
                (song) => !activePlaylist.some((qSong) => qSong.id === song.id)
            );

            if (availableSongs.length === 0) {
                console.warn("All unique random songs are currently in the queue. Re-using songs.");
                return hostedSongsList[Math.floor(Math.random() * hostedSongsList.length)]; // Pick any if no unique left
            }
            return availableSongs[Math.floor(Math.random() * availableSongs.length)];
        }

        /**
         * Advances to the next track in the playlist. Handles both manual and random playback logic.
         */
        function playNextTrack() {
            const activePlaylist = currentJamId ? jamSessionPlaylist : playlist;
            if (activePlaylist.length === 0) {
                resetPlayerUI();
                showMessage("Playlist is empty.", 3000);
                return;
            }

            if (currentJamId && !isHost && !myPermissions.play) {
                showMessage("You do not have permission to control playback in this jam.", 3000);
                return;
            }

            if (isPlayingRandomNetlifyMode) { // Changed to Netlify mode
                // In random mode, get a new random song and replace the current one in the queue
                const currentSongId = activePlaylist[currentTrackIndex]?.id;
                const indexToRemove = activePlaylist.findIndex(song => song.id === currentSongId);

                if (indexToRemove !== -1) {
                    activePlaylist.splice(indexToRemove, 1); // Remove the just played song
                }

                const newRandomSong = getUniqueRandomSongFromHostedList(); // Get one new song
                if (newRandomSong) {
                    activePlaylist.push(newRandomSong);
                } else {
                    showMessage("No more unique random songs to add. Re-shuffling pool.", 3000);
                    // If no new unique songs, consider re-fetching or handling exhaustion.
                    // For now, it will just use any song from the full list if no unique are left.
                }

                currentTrackIndex = 0; // Always play the first song in the (shuffled) random queue
                loadTrack(currentTrackIndex, true);

                if (currentJamId && isHost) {
                    updateFirestorePlaybackState(true, currentTrackIndex, 0); // Update Firestore
                }
            } else { // Manual playback logic (sequential)
                let nextIndex = currentTrackIndex + 1;
                if (nextIndex >= activePlaylist.length) {
                    nextIndex = 0; // Loop back to the beginning of the playlist
                }
                loadTrack(nextIndex, true);
                if (currentJamId && isHost) {
                    updateFirestorePlaybackState(true, nextIndex, 0); // Force sync new index and time
                }
            }
        }


        // --- Jam Session UI & Logic ---
        /**
         * Enables or disables UI controls based on whether the current client is the host
         * or has specific permissions in a jam session.
         * @param {boolean} enable - True to enable controls (e.g., if host), false to disable.
         */
        function enableClientControls(isHostStatus) { // Renamed parameter for clarity
            // General playback controls
            const playbackControls = [playPauseButton, rewindButton, forwardButton, nextButton, progressBar, volumeBar];
            playbackControls.forEach(btn => {
                if (btn) {
                    // Controls are enabled if current client is host OR if myPermissions.play is true
                    const shouldEnable = isHostStatus || myPermissions.play;
                    btn.disabled = !shouldEnable;
                    if (!shouldEnable) btn.classList.add('opacity-70', 'cursor-not-allowed');
                    else btn.classList.remove('opacity-70', 'cursor-not-allowed');
                }
            });
            // ProgressBar and VolumeBar are also inputs, so need pointer-events
            if(progressBar) {
                progressBar.style.pointerEvents = (isHostStatus || myPermissions.play) ? 'auto' : 'none';
            }
            if(volumeBar) {
                volumeBar.style.pointerEvents = (isHostStatus || myPermissions.play) ? 'auto' : 'none';
            }


            // Add Songs Button (now opens Netlify modal)
            const canAdd = isHostStatus || myPermissions.add;
            if (addSongsButton) {
                addSongsButton.disabled = !canAdd;
                if (!canAdd) addSongsButton.classList.add('opacity-70', 'cursor-not-allowed');
                else addSongsButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
            
            // Netlify Search input and button
            if (netlifySearchInput) netlifySearchInput.disabled = !canAdd;
            if (performNetlifySearchButton) {
                performNetlifySearchButton.disabled = !canAdd;
                if (!canAdd) performNetlifySearchButton.classList.add('opacity-70', 'cursor-not-allowed');
                else performNetlifySearchButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }

            // Random Hosted Songs button (now for Netlify)
            if (playRandomNetlifySongsButton) { // Renamed ID
                playRandomNetlifySongsButton.disabled = !canAdd;
                if (!canAdd) playRandomNetlifySongsButton.classList.add('opacity-70', 'cursor-not-allowed');
                else playRandomNetlifySongsButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }

            // Manage Playlist button (implies remove/add)
            const canManage = isHostStatus || myPermissions.remove || myPermissions.add; // Manage means remove/add
            if (managePlaylistButton) {
                managePlaylistButton.disabled = !canManage;
                if (!canManage) managePlaylistButton.classList.add('opacity-70', 'cursor-not-allowed');
                else managePlaylistButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }

            // YouTube Add controls in modal
            if (youtubeUrlInputModal) youtubeUrlInputModal.disabled = !canAdd;
            if (addFromUrlButton) {
                addFromUrlButton.disabled = !canAdd;
                if (!canAdd) addFromUrlButton.classList.add('opacity-70', 'cursor-not-allowed');
                else addFromUrlButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }
            if (youtubeTextSearchInput) youtubeTextSearchInput.disabled = !canAdd;
            if (performYoutubeTextSearchButton) {
                performYoutubeTextSearchButton.disabled = !canAdd;
                if (!canAdd) performYoutubeTextSearchButton.classList.add('opacity-70', 'cursor-not-allowed');
                else performYoutubeTextSearchButton.classList.remove('opacity-70', 'cursor-not-allowed');
            }

            // Dropdown options (three dots button)
            const optionsDropdownButtons = [openOptionsDropdownButton, addYoutubeSongDropdown, createJamSessionDropdownBtn, joinJamSessionDropdownBtn];
            optionsDropdownButtons.forEach(btn => {
                if (btn) {
                    // "Create Jam" is always available unless already in a jam.
                    // "Add YouTube Song" requires add permission.
                    if (btn.id === 'create-jam-session-dropdown-btn') {
                        btn.disabled = !!currentJamId; // Disable if already in a jam
                        if (btn.disabled) btn.classList.add('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                        else btn.classList.remove('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                    } else if (btn.id === 'add-youtube-song-dropdown') {
                        btn.disabled = !canAdd;
                        if (!canAdd) btn.classList.add('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                        else btn.classList.remove('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                    } else if (btn.id === 'join-jam-session-dropdown-btn') {
                        btn.disabled = !!currentJamId; // Disable if already in a jam
                         if (btn.disabled) btn.classList.add('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                        else btn.classList.remove('opacity-70', 'cursor-not-allowed', 'pointer-events-none');
                    } else { // For openOptionsDropdownButton itself
                        btn.disabled = false; // Always allow opening the dropdown
                        btn.classList.remove('opacity-70', 'cursor-not-allowed');
                    }
                }
            });
            
            // Playlist items' clickability (for playing) is handled within renderPlaylist now.
            // Editable playlist items' remove buttons (re-render handles this, but explicitly managing here for clarity)
            renderPlaylist(); // Call this to refresh track clickability and highlight
            renderEditablePlaylist(); // Call this to refresh remove button states
        }


        function showJamSessionUI(jamName, participants) {
            jamSessionInfoDiv.classList.remove('hidden');
            jamNameDisplay.textContent = jamName;
            // Map participant object to array of nicknames for display
            const participantNames = Object.values(participants).map(p => p.nickname || 'Anonymous');
            jamParticipantsDisplay.textContent = `Participants: ${participantNames.join(', ')}`;
            // Show permissions management section only if host
            if (isHost) {
                permissionsManagementDiv.classList.remove('hidden');
            } else {
                permissionsManagementDiv.classList.add('hidden');
            }
            updateParticipantsUI(); // Update detailed list and permission controls
        }

        function hideJamSessionUI() {
            jamSessionInfoDiv.classList.add('hidden');
            jamNameDisplay.textContent = '';
            jamParticipantsDisplay.textContent = '';
            permissionsManagementDiv.classList.add('hidden'); // Always hide when no jam
            permissionsList.innerHTML = ''; // Clear permissions list
            participantsList.innerHTML = ''; // Clear basic participants list
            currentJamId = null; // Clear jam ID as session is over or left
            isHost = false; // Not host anymore
            myNickname = ''; // Clear nickname
            myPermissions = { play: true, add: true, remove: true }; // Reset to default permissions for local playback
            enableClientControls(false); // Re-enable controls for local playback outside a jam
        }

        // --- Firestore Real-time Synchronization ---
        /**
         * Subscribes to real-time updates for a specific jam session document in Firestore.
         * @param {string} jamId - The ID of the jam session to listen to.
         */
        function subscribeToJamSessionUpdates(jamId) {
            if (unsubscribeJamListener) {
                unsubscribeJamListener(); // Unsubscribe from previous listener if any
            }
            if (!db) {
                console.error("Firestore DB not initialized. Cannot subscribe to updates.");
                return;
            }

            const jamRef = doc(db, 'jam_sessions', jamId);
            unsubscribeJamListener = onSnapshot(jamRef, (docSnapshot) => {
                if (docSnapshot.exists && docSnapshot.data().is_active) {
                    const jamData = docSnapshot.data();
                    console.log("Firestore Jam Data Update:", jamData);

                    // Update client's role and permissions
                    isHost = (jamData.host_sid === socket.id); // Determine if current client is the host
                    currentJamHostSid = jamData.host_sid; // Store host's SID
                    
                    // Update participants data and current client's permissions
                    jamSessionParticipants = jamData.participants || {}; // Entire participants map
                    myPermissions = jamSessionParticipants[socket.id]?.permissions || { play: false, add: false, remove: false }; // Get permissions for this client's SID

                    // Update UI for jam session info
                    showJamSessionUI(jamData.name || `Session ${jamId}`, jamSessionParticipants); // Pass the map
                    
                    // Render playlist (host or guest) - will re-render based on jamSessionPlaylist
                    jamSessionPlaylist = jamData.playlist || [];
                    renderPlaylist();
                    // Update controls based on new permissions (calls renderEditablePlaylist internally too)
                    enableClientControls(isHost); 

                    const playbackState = jamData.playback_state || {};
                    const newTrackIndex = playbackState.current_track_index; // Can be 0 or undefined
                    const newPlaybackTime = playbackState.current_playback_time || 0;
                    const newIsPlaying = playbackState.is_playing || false;
                    const lastSyncedAt = playbackState.timestamp || 0;

                    // Apply playback state if not host
                    if (!isHost) {
                        const currentTrack = jamSessionPlaylist[newTrackIndex];
                        const needsTrackLoad = (newTrackIndex !== currentTrackIndex || 
                                                (currentTrack && currentTrack.type === 'youtube' && youtubePlayer && youtubePlayer.getVideoData().video_id !== currentTrack.videoId) ||
                                                (currentTrack && currentTrack.type === 'audio' && audioPlayer.src !== currentTrack.url)); // Check for 'url' for audio tracks
                        
                        if (needsTrackLoad && newTrackIndex !== undefined && jamSessionPlaylist.length > newTrackIndex) {
                            currentTrackIndex = newTrackIndex; // Update local index
                            loadTrack(currentTrackIndex, newIsPlaying); // Load the new track
                        }

                        // Latency correction for playback time
                        const networkDelay = (Date.now() / 1000) - lastSyncedAt;
                        let targetTime = newPlaybackTime + networkDelay + 0.1; // Small buffer to account for command processing

                        if (currentTrack) {
                            let player;
                            let duration;
                            if (currentTrack.type === 'audio') {
                                player = audioPlayer;
                                duration = audioPlayer.duration; // Use actual audio element's duration
                            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                player = youtubePlayer;
                                duration = youtubePlayer.getDuration(); // Use YouTube player's duration
                            }
                            
                            // Only try to sync time/play if player is loaded and duration is valid
                            if (player && !isNaN(duration) && isFinite(duration) && duration > 0) {
                                targetTime = Math.min(Math.max(0, targetTime), duration); // Clamp target time within bounds

                                let currentTime = 0;
                                if (currentTrack.type === 'audio') {
                                    currentTime = audioPlayer.currentTime;
                                } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                    currentTime = youtubePlayer.getCurrentTime();
                                }
                                const timeDifference = Math.abs(currentTime - targetTime);

                                if (timeDifference > 1.0 || (newIsPlaying && (player.paused || (currentTrack.type === 'youtube' && player.getPlayerState() !== YT.PlayerState.PLAYING)))) { // Seek if more than 1 second out of sync OR if player is paused but should be playing
                                    console.log(`Follower Syncing: current ${currentTime.toFixed(2)}, target ${targetTime.toFixed(2)}, diff ${timeDifference.toFixed(2)}, delay ${networkDelay.toFixed(2)}`);
                                    if (currentTrack.type === 'audio') {
                                        player.currentTime = targetTime;
                                    } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                        player.seekTo(targetTime, true);
                                    }
                                }

                                // Play/pause state sync
                                if (newIsPlaying && (player.paused || (currentTrack.type === 'youtube' && player.getPlayerState() !== YT.PlayerState.PLAYING))) {
                                    if (currentTrack.type === 'audio') {
                                        player.play().catch(e => console.error("Error playing audio (guest):", e));
                                    } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                        youtubePlayer.playVideo();
                                    }
                                } else if (!newIsPlaying && (!player.paused || (currentTrack.type === 'youtube' && player.getPlayerState() === YT.PlayerState.PLAYING))) {
                                    if (currentTrack.type === 'audio') {
                                        player.pause();
                                    } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                                        youtubePlayer.pauseVideo();
                                    }
                                }
                            } else {
                                console.warn("Guest: Player or duration not ready for sync.");
                            }
                        }
                        showMessage("Syncing with Jam Session!", 1000);
                    } else { // If host, just ensure UI reflects latest state and controls are enabled based on initial load
                        enableClientControls(true); // Host always has all controls
                    }

                    // Update participants UI regardless of host status
                    updateParticipantsUI();

                } else {
                    // Session ended or document no longer exists in Firestore
                    showMessage(`Jam Session "${jamId}" has ended.`, 5000);
                    hideJamSessionUI(); // Reset UI to local state
                    resetPlayerUI();
                    playlist.length = 0; // Clear local playlist as well after jam ends
                    renderPlaylist(); // Show empty local playlist
                    clearInterval(syncInterval); // Stop any host sync interval
                    if (unsubscribeJamListener) {
                        unsubscribeJamListener(); // Unsubscribe from Firestore
                        unsubscribeJamListener = null;
                    }
                }
            }, (error) => {
                console.error("Error listening to jam session updates:", error);
                showMessage("Lost connection to Jam Session. Please try rejoining.", 5000);
                hideJamSessionUI();
                resetPlayerUI();
                playlist.length = 0;
                renderPlaylist();
                clearInterval(syncInterval);
                if (unsubscribeJamListener) unsubscribeJamListener();
            });
        }

        // Host-only function to update Firestore with current playback state
        async function updateFirestorePlaybackState(isPlayingOverride = null, trackIndexOverride = null, playbackTimeOverride = null) {
            if (!currentJamId || !isHost || !db) return;

            const currentTrack = jamSessionPlaylist[currentTrackIndex]; // Host manages its jamSessionPlaylist
            if (!currentTrack) return;

            let currentTime = playbackTimeOverride !== null ? playbackTimeOverride : 0;
            let isPlaying = isPlayingOverride !== null ? isPlayingOverride : false;
            let trackIndex = trackIndexOverride !== null ? trackIndexOverride : currentTrackIndex;

            if (currentTrack.type === 'audio') {
                currentTime = playbackTimeOverride !== null ? playbackTimeOverride : audioPlayer.currentTime;
                isPlaying = isPlayingOverride !== null ? isPlayingOverride : !audioPlayer.paused;
            } else if (currentTrack.type === 'youtube' && youtubePlayerReady) {
                currentTime = playbackTimeOverride !== null ? playbackTimeOverride : youtubePlayer.getCurrentTime();
                isPlaying = isPlayingOverride !== null ? isPlayingOverride : (youtubePlayer.getPlayerState() === YT.PlayerState.PLAYING);
            } else if (currentTrack.type === 'youtube_download') {
                // During download, treat as paused
                isPlaying = false;
            }

            try {
                await updateDoc(doc(db, 'jam_sessions', currentJamId), {
                    'playback_state.current_track_index': trackIndex,
                    'playback_state.current_playback_time': currentTime,
                    'playback_state.is_playing': isPlaying,
                    'playback_state.timestamp': Date.now() / 1000 // Client timestamp for latency calculation
                });
                // Firestore listener will handle propagation to all clients (including host's own UI)
            } catch (e) {
                console.error("Error updating Firestore playback state:", e);
                showMessage("Failed to sync playback state to jam. Check connection.", 3000);
            }
        }

        /**
         * Updates the participants list in the UI and their permission controls (if current client is host).
         */
        function updateParticipantsUI() {
            // Update the count for the general participants display
            const participantCount = Object.keys(jamSessionParticipants).length;
            document.querySelector('#jam-session-info #jam-participants-display').textContent = `Participants: ${Object.values(jamSessionParticipants).map(p => p.nickname).join(', ')}`;
            // Update the more detailed participants list
            const detailedParticipantsCountSpan = document.getElementById('participants-count');
            if (detailedParticipantsCountSpan) {
                 detailedParticipantsCountSpan.textContent = `Participants (${participantCount}):`;
            }

            participantsList.innerHTML = ''; // Clear existing basic list
            permissionsList.innerHTML = ''; // Clear existing permission controls

            const participantEntries = Object.entries(jamSessionParticipants); // Get [sid, {data}] pairs

            participantEntries.forEach(([sid, data]) => {
                const isMe = (sid === socket.id);
                const participantIsHost = (sid === currentJamHostSid);

                const nickname = data.nickname || 'Unknown';
                const permissions = data.permissions || { play: false, add: false, remove: false };

                // Display participant in general list
                const participantLi = document.createElement('li');
                participantLi.className = 'py-1 text-gray-700 dark:text-gray-300';
                participantLi.textContent = `${nickname} ${isMe ? '(You)' : ''} ${participantIsHost ? '(Host)' : ''}`;
                participantsList.appendChild(participantLi);

                // If current client is the host, render permission controls for others
                if (isHost && !isMe) { // Host can manage others' permissions (but not their own or their co-hosts/other hosts)
                    const permissionItem = document.createElement('div');
                    permissionItem.className = 'flex items-center space-x-2 bg-gray-100 p-2 rounded-md mb-1';
                    permissionItem.innerHTML = `
                        <span class="font-medium text-gray-800 flex-shrink-0 w-24 truncate">${nickname}</span>
                        <label class="inline-flex items-center">
                            <input type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" data-permission="play" data-sid="${sid}" ${permissions.play ? 'checked' : ''}>
                            <span class="ml-1 text-sm text-gray-700">Play</span>
                        </label>
                        <label class="inline-flex items-center ml-2">
                            <input type="checkbox" class="form-checkbox h-4 w-4 text-green-600" data-permission="add" data-sid="${sid}" ${permissions.add ? 'checked' : ''}>
                            <span class="ml-1 text-sm text-gray-700">Add</span>
                        </label>
                        <label class="inline-flex items-center ml-2">
                            <input type="checkbox" class="form-checkbox h-4 w-4 text-red-600" data-permission="remove" data-sid="${sid}" ${permissions.remove ? 'checked' : ''}>
                            <span class="ml-1 text-sm text-gray-700">Remove</span>
                        </label>
                    `;
                    permissionsList.appendChild(permissionItem);

                    // Add event listeners for permission checkboxes
                    permissionItem.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                        checkbox.addEventListener('change', (event) => {
                            const targetSid = event.target.dataset.sid;
                            const permissionType = event.target.dataset.permission;
                            const isChecked = event.target.checked;
                            const updatedPerms = { [permissionType]: isChecked };
                            socket.emit('update_participant_permissions', {
                                jam_id: currentJamId,
                                target_sid: targetSid,
                                permissions: updatedPerms
                            });
                        });
                    });
                }
            });

            // Show/hide permissions management section based on host status
            if (isHost) {
                permissionsManagementDiv.classList.remove('hidden');
            } else {
                permissionsManagementDiv.classList.add('hidden');
            }
        }


        // --- Event Listeners ---

        // "Add Songs" button (now toggles Netlify Local MP3 search section)
        addSongsButton.addEventListener('click', () => {
            console.log("Add Songs button clicked (toggling Netlify Search Section)");
            // Check for add permission
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to add songs to this jam.", 3000);
                return;
            }
            netlifySearchSection.classList.toggle('hidden'); // Toggle visibility
            // Ensure other modals are closed when this section is opened
            if (!netlifySearchSection.classList.contains('hidden')) {
                closeYoutubeModal();
                closeManagePlaylistModal();
                closeCreateJamModal();
                closeJoinJamModal();
            }
            optionsDropdown.classList.add('hidden'); // Ensure dropdown is closed
        });

        // "Three dots" button (opens options dropdown)
        openOptionsDropdownButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Prevent document click from immediately closing it
            console.log("Three dots button clicked");
            optionsDropdown.classList.toggle('hidden'); // Toggle dropdown visibility
            // Close other modals/sections if open
            closeYoutubeModal();
            hideNetlifySearchSection(); // Hide Netlify search section
            closeManagePlaylistModal();
            closeCreateJamModal();
            closeJoinJamModal();
        });

        // Hide dropdown if clicked outside
        document.addEventListener('click', (event) => {
            if (optionsDropdown && !optionsDropdown.contains(event.target) && !openOptionsDropdownButton.contains(event.target)) {
                optionsDropdown.classList.add('hidden');
            }
        });

        // Handle "Add YouTube Song" click from dropdown
        addYoutubeSongDropdown.addEventListener('click', (event) => {
            event.preventDefault(); // Prevent default link behavior
            // Check for add permission
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to add songs to this jam.", 3000);
                optionsDropdown.classList.add('hidden'); // Hide dropdown
                return;
            }
            openYoutubeModal();
            optionsDropdown.classList.add('hidden'); // Hide dropdown after selection
        });

        // Handle "Create Jam Session" click from dropdown
        createJamSessionDropdownBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Prevent default link behavior
            if (currentJamId) {
                showMessage("You are already in a Jam Session. Leave the current one first.", 3000);
                optionsDropdown.classList.add('hidden');
                return;
            }
            openCreateJamModal();
            optionsDropdown.classList.add('hidden'); // Hide dropdown after selection
        });

        // Handle "Join Jam Session" click from dropdown
        joinJamSessionDropdownBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Prevent default link behavior
            if (currentJamId) {
                showMessage("You are already in a Jam Session. Leave the current one first.", 3000);
                optionsDropdown.classList.add('hidden');
                return;
            }
            openJoinJamModal(null, "Existing Session"); // Open with empty ID for user to type
            optionsDropdown.classList.add('hidden'); // Hide dropdown after selection
        });

        // Handle Create Jam Session button within the modal
        createJamButton.addEventListener('click', async () => {
            if (!userId) {
                showMessage("Authentication not ready. Please wait or refresh.", 3000);
                return;
            }
            const jamName = jamNameInput.value.trim(); // Matched ID with HTML
            const nickname = nicknameInputCreate.value.trim(); // Matched ID with HTML
            if (!nickname) {
                showMessage("Please enter your nickname to create a session.", 3000);
                return;
            }
            myNickname = nickname;
            
            // Emit to backend, backend saves to Firestore and returns jam_id
            socket.emit('create_session', { jam_name: jamName, nickname: nickname });
            closeCreateJamModal(); // Close modal immediately
            // The 'session_created' event will be received from the backend, which will then trigger Firestore listener
        });

        // Handle Copy Share Link button
        copyShareLinkButton.addEventListener('click', () => {
            const link = jamShareLinkInput.value;
            if (link) {
                // Using modern clipboard API with fallback
                navigator.clipboard.writeText(link).then(() => {
                    showMessage("Link copied to clipboard!", 2000);
                }).catch(err => {
                    console.error('Failed to copy text using navigator.clipboard:', err);
                    // Fallback for older browsers / restricted environments
                    const el = document.createElement('textarea');
                    el.value = link;
                    document.body.appendChild(el);
                    el.select();
                    document.execCommand('copy');
                    document.body.removeChild(el);
                    showMessage("Link copied to clipboard (fallback)!", 2000);
                });
            }
        });

        // Handle Join Jam Session button within the modal
        joinJamButton.addEventListener('click', async () => {
            if (!userId) {
                showMessage("Authentication not ready. Please wait or refresh.", 3000);
                return;
            }
            const nickname = nicknameInputJoin.value.trim(); // Matched ID with HTML
            const enteredJamId = joinJamIdInput.value.trim(); // Matched ID with HTML
            if (!nickname) {
                showMessage("Please enter your nickname to join the session.", 3000);
                return;
            }
            if (!enteredJamId) {
                showMessage("Please enter a Jam ID.", 3000);
                return;
            }

            myNickname = nickname;
            currentJamId = enteredJamId; // Set the jamId to be joined locally
            
            // Emit to backend, backend joins in Firestore
            socket.emit('join_session', { jam_id: currentJamId, nickname: nickname });
            closeJoinJamModal(); // Close modal immediately
            // Firestore listener will update the state
        });

        // Handle Leave Jam Session button (uses new confirmation modal)
        leaveJamSessionButton.addEventListener('click', () => {
            if (currentJamId && socket && userId) {
                showConfirmation(
                    "Leave Jam Session?",
                    "Are you sure you want to leave this jam session? If you are the host, the session will end for everyone.",
                    async (confirmed) => {
                        if (confirmed) {
                            try {
                                const jamRef = doc(db, 'jam_sessions', currentJamId);
                                const jamDoc = await getDoc(jamRef);
                                if (jamDoc.exists) {
                                    const jamData = jamDoc.data();
                                    // Check if current client is the host of this jam
                                    if (jamData.host_sid === socket.id) { 
                                        await updateDoc(jamRef, {
                                            is_active: false, // Mark session as inactive
                                            ended_at: new Date()
                                        });
                                        showMessage("You have ended the Jam Session for everyone.", 3000);
                                        // No explicit socket.emit('disconnect') here; Firestore update propagates
                                    } else { // This is a participant
                                        const updatedParticipants = jamData.participants || {};
                                        delete updatedParticipants[socket.id]; // Remove self from participants map
                                        await updateDoc(jamRef, {
                                            participants: updatedParticipants
                                        });
                                        showMessage("You have left the Jam Session.", 3000);
                                    }
                                }
                            } catch (e) {
                                console.error("Error leaving jam session:", e);
                                showMessage("Error leaving jam session. Please try again.", 3000);
                            } finally {
                                // Reset client-side state after attempting Firestore update
                                currentJamId = null;
                                isHost = false;
                                myNickname = '';
                                jamSessionPlaylist = [];
                                jamSessionParticipants = {}; // Reset to empty object
                                myPermissions = { play: true, add: true, remove: true }; // Reset to default for local
                                hideJamSessionUI();
                                resetPlayerUI();
                                playlist.length = 0; // Clear local playlist
                                renderPlaylist(); // Show empty local playlist
                                clearInterval(syncInterval); // Stop any host sync interval
                                if (unsubscribeJamListener) {
                                    unsubscribeJamListener(); // Unsubscribe from Firestore
                                    unsubscribeJamListener = null;
                                }
                            }
                        }
                    }
                );
            } else {
                showMessage("You are not currently in a jam session.", 3000);
            }
        });


        // "Manage Playlist" button
        managePlaylistButton.addEventListener('click', openManagePlaylistModal);

        // Netlify Section -> Search by Name
        performNetlifySearchButton.addEventListener('click', async () => {
            const query = netlifySearchInput.value.trim();
            if (!query) { showMessage("Please enter a search query.", 2000); return; }

            // Check for add permission
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to search/add songs to this jam.", 3000);
                return;
            }

            const results = searchNetlifyMp3s(query); // Call the local search function
            renderNetlifySearchResults(results, netlifySearchResults);
        });

        // YouTube Modal -> Add by URL
        addFromUrlButton.addEventListener('click', async () => {
            const url = youtubeUrlInputModal.value.trim();
            if (!url) { showMessage("Please enter a YouTube URL.", 2000); return; }

            // Check for add permission
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to add songs to this jam.", 3000);
                return;
            }

            const videoId = extractYouTubeVideoId(url);
            if (!videoId) { showMessage("Invalid YouTube URL.", 2000); return; }
            const track = await getYouTubeVideoDetails(videoId);
            if (track) {
                addSongToCurrentPlaylist(track);
                closeYoutubeModal();
            }
        });

        // YouTube Modal -> Search by Name
        performYoutubeTextSearchButton.addEventListener('click', async () => {
            const query = youtubeTextSearchInput.value.trim();
            if (!query) { showMessage("Please enter a search query.", 2000); return; }

            // Check for add permission
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to search/add songs to this jam.", 3000);
                return;
            }

            const results = await searchYouTubeVideos(query);
            renderYouTubeSearchResults(results);
        });

        // "Play Random Netlify Songs" button (Renamed from Play Random Drive Songs)
        playRandomNetlifySongsButton.addEventListener('click', async () => {
            // Check for add permission
            if (currentJamId && !isHost && !myPermissions.add) {
                showMessage("You do not have permission to initiate random playback in a Jam Session.", 3000);
                return;
            }
            if (hostedSongsList.length === 0) {
                showMessage("No hosted songs available for random playback. Manifest might not be loaded.", 6000);
                return;
            }
            await startDynamicRandomPlaybackNetlify(); // Call the Netlify specific random play
        });

        /**
         * Handles the initial load of the application and checks for jam session parameters in the URL.
         * This function is called once Firebase authentication state is determined.
         */
        async function handleInitialLoadAndJamJoin() {
            renderPlaylist(); // Render initial empty playlist or saved local one

            // Initialize volume slider from current player volume
            volumeBar.value = audioPlayer.volume * 100;
            volumeBar.style.setProperty('--volume', `${volumeBar.value}%`);


            // Hide all modals and sections initially
            if(netlifySearchSection) netlifySearchSection.classList.add('hidden'); // NEW: Hide Netlify section
            if(youtubeModal) youtubeModal.classList.add('hidden');
            if(managePlaylistModal) managePlaylistModal.classList.add('hidden');
            if(createJamModal) createJamModal.classList.add('hidden');
            if(joinJamModal) joinJamModal.classList.add('hidden');
            if(optionsDropdown) optionsDropdown.classList.add('hidden');
            if(jamSessionInfoDiv) jamSessionInfoDiv.classList.add('hidden'); // Hide jam controls initially
            if(permissionsManagementDiv) permissionsManagementDiv.classList.add('hidden'); // Hide permissions management initially


            // Check URL for jam_id on page load (e.g., from a shared link)
            const urlParams = new URLSearchParams(window.location.search);
            const urlJamId = urlParams.get('jam_id') || (window.location.pathname.startsWith('/join/') ? window.location.pathname.substring(6) : null);
            
            if (urlJamId) {
                // If jam_id is present, open the join modal automatically
                // The actual jam name will be fetched in openJoinJamModal
                await openJoinJamModal(urlJamId, `Session ${urlJamId}`);
                // Clear the URL parameter so refreshing doesn't re-prompt
                const newUrl = window.location.origin + window.location.pathname.replace(`/join/${urlJamId}`, '').split('?')[0];
                history.replaceState(null, '', newUrl); // Remove query param or path segment
            } else {
                showMessage("Welcome! Use 'Add Songs' or 'Play Random Netlify Songs'.", 3000); // Updated message
                // Set default track info if no jam is active
                trackTitle.textContent = "No song loaded";
                artistName.textContent = "";
                albumArt.src = "https://placehold.co/128x128/CCCCCC/FFFFFF?text=No+Track";
            }
            enableClientControls(false); // Initially disable controls for guests not in a jam or for anonymous users until auth state is known.
                                       // This will be overridden by Firebase onAuthStateChanged if they join a jam.
        }
        
        // This function will be called on 'DOMContentLoaded' or after Firebase auth state is known.
        // It's called from onAuthStateChanged to ensure Firebase is ready.
        document.addEventListener('DOMContentLoaded', () => {
            // Load hosted songs manifest at DOMContentLoaded
            loadHostedSongsManifest();

            // Setup Socket.IO connection as soon as DOM is ready, before Firebase auth might resolve
            // Firebase auth will then call handleInitialLoadAndJamJoin
            socket.on('connect', () => {
                console.log('Socket.IO connected:', socket.id);
                // After Socket.IO connects, Firebase auth state change listener will trigger
            });

            socket.on('disconnect', () => {
                console.log('Socket.IO disconnected.');
                // Handle UI reset/message if disconnected outside of intentional leave
                if (currentJamId) { // If still in a jam, it's an unexpected disconnect
                    showMessage("Lost connection to the server. Jam features may be affected.", 5000);
                }
            });

            socket.on('session_created', async (data) => {
                currentJamId = data.jam_id;
                isHost = true; // Current client is the host
                myNickname = data.nickname_used;
                currentJamHostSid = socket.id; // Store own SID as host

                // Set initial permissions for the host
                myPermissions = { play: true, add: true, remove: true };

                console.log(`Jam session "${data.jam_name}" created with ID: ${currentJamId}`);
                showMessage(`Jam session "${data.jam_name}" created! Share ID: ${currentJamId}`, 5000);

                const jamShareLinkInput = document.getElementById('jam-share-link');
                const shareLinkContainer = document.getElementById('share-link-container');
                if (jamShareLinkInput && shareLinkContainer) {
                    jamShareLinkInput.value = data.shareable_link;
                    shareLinkContainer.classList.remove('hidden');
                }

                // Subscribe to Firestore updates for the newly created session
                subscribeToJamSessionUpdates(currentJamId);
                // Host begins syncing playback state to Firestore
                clearInterval(syncInterval);
                syncInterval = setInterval(updateFirestorePlaybackState, 3000); // Sync every 3 seconds
                showJamSessionUI(data.jam_name, data.participants);
                enableClientControls(true); // Host has all controls
                renderPlaylist(); // Render empty playlist initially for host
                resetPlayerUI(); // Ensure player is reset
            });

            socket.on('session_join_success', async (data) => {
                currentJamId = data.jam_id;
                isHost = false; // Not the host
                myNickname = data.nickname_used;
                currentJamHostSid = data.host_sid; // Get host's SID

                // Get initial permissions for this client
                myPermissions = data.participants[socket.id]?.permissions || { play: false, add: false, remove: false };

                console.log(`Joined jam session "${data.jam_name}". Jam ID: ${currentJamId}`);
                showMessage(`Joined jam session "${data.jam_name}". Welcome, ${myNickname}!`, 5000);

                // Subscribe to Firestore updates for the joined session
                subscribeToJamSessionUpdates(currentJamId);
                // The onSnapshot listener will handle updating playlist and playback state
                clearInterval(syncInterval); // Ensure sync interval is cleared for guests
                showJamSessionUI(data.jam_name, data.participants);
                enableClientControls(false); // Guests start with disabled controls (permissions will enable selectively)
            });

            socket.on('join_failed', (data) => {
                console.error("Jam join failed:", data.message);
                showMessage(`Failed to join jam: ${data.message}`);
                // Reset client-side state if join fails
                currentJamId = null;
                isHost = false;
                myNickname = '';
                jamSessionPlaylist = [];
                jamSessionParticipants = {};
                myPermissions = { play: true, add: true, remove: true }; // Reset to default for local
                hideJamSessionUI();
                resetPlayerUI();
                playlist.length = 0;
                renderPlaylist();
                clearInterval(syncInterval);
                if (unsubscribeJamListener) {
                    unsubscribeJamListener();
                    unsubscribeJamListener = null;
                }
            });

            socket.on('permission_denied', (data) => {
                console.warn(`Permission denied for action: ${data.action} - ${data.message}`);
                showMessage(`Permission Denied: ${data.message}`, 4000);
            });
        });

    </script>
</body>
</html>
